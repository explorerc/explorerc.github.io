[{"title":"Vue命名路由","date":"2019-02-14T08:34:00.000Z","path":"2019/02/14/190214-vue命名路由/","text":"有时候，通过一个名称来表示一个路由显得更方便一些，特别是在连接一个路由，或者执行一些跳转的时候。我们可以在创建Router实例的时候，在routes配置中给某个路由设置名称 命名路由 123456789cosnt router = newRouter(&#123; routes: [ &#123; path: '/user/:userId', name: 'user', component: User &#125; ]&#125;) 名字跳转 &lt;router-link :to=&quot;{name: 'user', params: { userId: 123 }}&quot;&gt;User&lt;/router-link&gt; router.push({name: 'user', params: {userId:123}) 路径跳转 &lt;router-link :to=&quot;/user/123&quot;&gt;User&lt;/router-link&gt; router.push('/user/123&quot;')","tags":[{"name":"路由","slug":"路由","permalink":"http://haojen.github.io/tags/路由/"},{"name":"vue","slug":"vue","permalink":"http://haojen.github.io/tags/vue/"}]},{"title":"js中的同步与异步","date":"2019-02-14T03:24:00.000Z","path":"2019/02/14/190214-同异步/","text":"在我们写一些方法的是，同步与异步这个问题是是非重要的，有可能关系到我们能否拿到某个值的问题 概念 同步：简单理解事情发生有严格的先后顺序，一个时间点只会发生一件事情 异步：一个时间点会发生一件活多件事情，事情的发生互相不耽误 javascript是一门&quot;单线程&quot;的语言，就想一条流水线，要么加工，要么包装，不能同时进行多个任务和流程 setTimeout和setInterval 最基础的异步是setTimeout和setInterval函数，很常见，但是很少人有人知道其实这就是异步，因为它们可以控制js的执行顺序。 我们也可以简单地理解为：可以改变程序正常执行顺序的操作就可以看成是异步操作。 尽管setTimeout的time延迟时间为0，其中的function也会被放图一个队列中(任务队列)，等待下一个机会执行，当前的代码 (指不需要加入队列中的程序）必须在该队列的程序完成之前玩笑，因此结果可能与预期结果不相同 队列（任务队列），放的就是setTimeout中的function，这些function依次加入该队列, 即该队列中所有function中的程序将会在该队列意外的所有代码执行完毕后在依次执行。因为在执行程序的时候, 浏览器会默认setTimeout以及ajax请求请求这一类的方法都是耗时程序（尽管可能不耗时)，将这些加入一个对垒中， 该队列是一个存储耗时程序的队列，在所有不耗时程序执行完成，再来依次执行该队列中的程序。 javascript是单线程。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长, 后一个任务就不得不一直等着。于是就有一个概念——任务队列。如果排队是因为计算量大，CPU忙不过来， 倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。 于是JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。 等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。 于是，所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous。 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有等主线程任务执行完毕，&quot;任务队列&quot;开始通知主线程，请求执行任务，该任务才会进入主线程执行。 运行机制 所有同步任务都在主线程上执行，形成一个执行栈（execute context stack） 主线程之外，加油一个&quot;任务对垒&quot;（task queue）。只有异步任务有了运行结果，就在&quot;任务队列&quot;之中放置一个事件。 一旦&quot;执行栈&quot;中的所有同步任务执行完毕，系统就会读取&quot;执行队列&quot;，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。 主线程不断重复上面的第三部 &quot;任务队列&quot;是一个事件的队列（也可以理解成消息的队列），IO设备完成一项任务，就在&quot;任务队列&quot;中添加一个事件，表示相关的异步任务可以进入&quot;执行栈&quot;了。主线程读取&quot;任务队列&quot;，就是读取里面有哪些事件。 &quot;任务队列&quot;中的事件，除了IO设备的事件以外，还包括一些用户产生的事件（比如鼠标点击、页面滚动等等），比如$(selectot).click(function)，这些都是相对耗时的操作。只要指定过这些事件的回调函数，这些事件发生时就会进入&quot;任务队列&quot;，等待主线程读取。 所谓&quot;回调函数&quot;（callback），就是那些会被主线程挂起来的代码，前面说的点击事件$(selectot).click(function)中的function就是一个回调函数。异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。例如ajax的success，complete，error也都指定了各自的回调函数，这些函数就会加入“任务队列”中，等待执行。 文献参考：YinghaoGuo：js中的同步和异步的个人理解","tags":[{"name":"html","slug":"html","permalink":"http://haojen.github.io/tags/html/"},{"name":"js","slug":"js","permalink":"http://haojen.github.io/tags/js/"}]},{"title":"Vue-route导航守卫","date":"2019-02-12T16:00:00.000Z","path":"2019/02/13/190213-beforEach /","text":"vue-route提供的beforeRouteUpadate可以方便实现导航守卫 官方文档 全局前置守卫 1、注册全局前置守卫（router.beforeEach） 12345const router = new VueRouter(&#123; ... &#125;)router.beforeEach((to, from, next) =&gt; &#123; // ...&#125;) to: 即将进入的目标路由对象 from： 当前导航真要离开的路由 next： 一定要调用该方法来resolve这个钩子，执行效果依赖next方法调用参数。 next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed （确认的）。 next(false): 中断当前的导航。如果浏览器的 URL 改变了（可能是用户手动或者浏览器后退按钮），那么 URL 地址会重置到 from 路由对应的地址。 next('/') 或者 next({ path: '/' }): 跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。 next(error): (2.4.0+) 如果传入 next 的参数是一个 Error 实例，则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。 全局后置钩子 我们可以注册全局后置钩子，然后和守卫不同的是，这些钩子不会接受next函数也不会该拜年导航本身 123router.afterEach((to, from) =&gt; &#123; // ...&#125;) 路由独享守卫 我们可以在路由配置上直接定义beforeEnter守卫： 1234567891011const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // .... &#125; &#125; ]&#125;) 守卫与全局前置守卫的方法参数是一样的 组件内的守卫 123456789101112131415161718const Foo = &#123; tmeplate: '...', beforeRouterEnter (to, from, next) &#123; // 在渲染该组件的对应路由被confirm前调用 // 不能获取组件实例'this' // 因为当守卫执行前，组件实例还没有被创建 &#125;, beforeRouterUpdate (to, from, next) &#123; // 在当前路由改变，当时该组件被恢复使用是调用 // 举例来说，对于一个动态路由，/foo/:id，在/foo/1和/foo/2之间跳转的时候 // 由于会渲染同样的Foo组件，因此组件实例会被复用。二这个钩子就会在这个情况被调用 // 可以访问组件实例'this' &#125;, beforeRouterLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例'this' &#125;&#125; beforeRouterEnter可以通过穿一个回调给next来访问组件实例。在导航被确认的时候执行回调，并且把组件实例做为回调方法的参数 12345beforeRouterEnter (to, from, next) &#123; next(vm =&gt; &#123; // t通过vm访问组件实例 &#125;)&#125; 提醒保存 123456789beforeRouterLeave (to, from, next) &#123; const answer = window.confirm('是否保存修改') if (answer) &#123; this.save() next() &#125; else &#123; next(false) &#125;&#125; 完整的导航解析流程 导航被触发 在失活的组件里调用离开守卫 调用全局的beforeEach守卫 在重用组件里调用beforeRouteUpdate守卫 在路由配置里调用beforeEnter 解析异步路由组件。 在被激活的组件里调用beforeRouteEnter 调用全局的beforeResolve守卫 导航被确认 调用全局的afterEach钩子 触发DOM更新 在创建好的实例跳用beforeRouteEnter守卫中传给next的回调函数","tags":[{"name":"Vue","slug":"Vue","permalink":"http://haojen.github.io/tags/Vue/"},{"name":"Vue-Router","slug":"Vue-Router","permalink":"http://haojen.github.io/tags/Vue-Router/"},{"name":"beforEach","slug":"beforEach","permalink":"http://haojen.github.io/tags/beforEach/"}]},{"title":"vuex2","date":"2019-02-11T16:00:00.000Z","path":"2019/02/12/190212-vuex2/","text":"Vuex是一个专为Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化.Vuex也集成到Vue的官方调试工具devtools扩展，提供了诸如零配置的time-travel调试，状态快照导入导出等高级调试功能。 官方文档 安装 npm 1npm install vuex --save 模块化的项目中，必须通过Vue.user()来引用Vuex 就拿一个我们公司现在完整vue项目来说，我们需要在一个store中index.js文件（全局）中引用 12import Vuex from 'vuex'Vue.use(Vuex) promise 1npm install es6-promise --save 入门 最简单的store 定义 12345678910const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment: state =&gt; state.count++, decrement: state =&gt; state.count-- &#125; &#125;)&#125;) 使用 12345&lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;&lt;p&gt; &lt;button @click=\"increment\"&gt;+&lt;/button&gt; &lt;button @click=\"decrement\"&gt;-&lt;/button&gt;&lt;/p&gt; 12345678910111213computed: &#123; count () &#123; return store.state.count &#125;&#125;,methods: &#123; increment () &#123; store.commit('increment') &#125;, decrement () &#123; store.commit('decrement') &#125;&#125; 通过提交变异的方式，而非直接改变store.state.count state 由于Vuex的状态存储是响应式的，从商店实例中读取状态最简单的方法就是在计算属性中返回某个状态 每当store.state.count变化的时候，都会重新求取计算属性，并且触发更新相关联的DOM。 mapState 辅助函数 当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余为了解决这个问题，我们可以使用。mapState辅助函数帮助我们生成计算属性，让你少按几次键 123456789101112131415// 在单独构建的版本中辅助函数为 Vuex.mapStateimport &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 'count' 等同于 `state =&gt; state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;)&#125; 展开运算符 1234567computed: &#123; localComputed () &#123; /* ... */ &#125;, // 使用对象展开运算符将此对象混入到外部对象中 ...mapState(&#123; // ... &#125;)&#125; getters Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) 通过属性访问 Getter会暴露为store.getter对象，可以以属性的形式访问这些值 1store.getters.doneTodos // -&gt;[&#123; id: 1, text: '...', done: true &#125;] 通过方法访问 getter返回一个函数，实现给getter传参 12345getters: &#123; getTodoId: (state) =&gt; (id) =&gt; &#123; return state.todos.find(todo =&gt; todo.id === id) &#125;&#125; 1store.gettes.getTodoId(2) 注意：getter在通过方法访问时hi，每次都会区进行调用，不会缓存结果 maoGetters辅助函数 maoGetters辅助韩式仅仅是将store中的getter映射到局部计算属性 123456789import &#123; mapGetters &#125; from 'vuex'export default &#123; computed: &#123; ...mapGettes([ 'doneTodoCount', 'anotherGetter': 'otherGetter' //将getter的anotherGetter属性重命名为otherGetter ]) &#125;&#125; Mutation 更改Vuex的store中的唯一方法就是提交mutation。Vuex中的mutaion非常类似组件中的methods；每个mutation否有一个字符串的时间类型（tupe）和一个回调函数（handler）。这个回调函数就是我们实际进行状态更改的地方，并且它会接受state做为第一个参数 1代码请看 入门中的代码 提交载荷（Payload） 可以想store.commit提交额外的参数，即mutation的载荷（payload） 123456mutation: &#123; increment (state, n) &#123; state.count += n // n为简单数据类型时 state.count += n.amount // n为对象时 &#125;&#125; 1store.commit('increment', 10) 当n是一个对象时 1store.commit('increment', &#123;amount: 10&#125;) Mutation需要遵守Vue的相映规则 最好提前初始化store的所有所需属性 需要在对象上添加新的属性是， 使用Vue.set(obj,'newProp',123) 或者 以新替旧 1state.obj = &#123; ...state.obj, newProp: 123 &#125; 使用常量替代Mutation事件类型 使用常量替代Mutation事件类型在各种Flux实现中是最常见的模式。这样可以使linter之类的股票民航局发挥作用，把常量放在单独嗯文件中是整个项目包含的mutation一目了然 12// mutation-type.jsexport const SOME_MUTATION = 'SOME_MUTATION' 12345678import Vuex from 'vuex'import &#123; SOME_MUTATION &#125; from './mutation-type'const store = new Vuex.Srore(&#123; state: &#123;...&#125; mutation: &#123; [SOME_MUTATION] (state) &#123;&#125; &#125;&#125;) Mutation必须是同步函数 在组件中提交Mutation 在组件中可以使用this.$store.commit('increment')提交mutation，也可以使用mapMutation富足函数将组件中的methods映射为store.commit调用 1234567891011121314import &#123; mapMutation &#125; from 'vuex'export default = &#123; methods: &#123; ...mapMutation([ 'increment', // 将this.increment()映射为this.$store.commit('increment') 'incrementBy' // 将this.incrementBy(amount)映射为this.$store.commit('incrementBy', amount) ]), &#125; methods: &#123; ...mapMutation([ add: 'increment', // 将this.add()映射为this.$store.commit('increment') // 我们项目主要用的这种 ]) &#125;&#125; Action Action类似于mutation，不同点 Action提交的是mutation，而不是直接变更状态。 Action可以班汉任意异步操作 12345678const store = new Vuex.store (&#123; // ... actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) Action函数接受一个与store实例具有相同方法和属性的context对象。context.commit提交一个mutation，或者通过context.state和context.getters来获取state和getters。 12345actions: &#123; increment (&#123; commit &#125;) &#123; commit('increment') &#125;&#125; 分发Action 1store.dispatch('increment') mutation必须同步执行，Action不受约束，可以在action内部进行异步执行 1234567actions: &#123; incrementAsync (&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit('increment') &#125;, 1000) &#125;&#125; Action支持载荷方式和对象方式进行分发 123456789// 载荷方式store.dispatch('incrementAsync', &#123; amoutn: 10&#125;)// 对象方式store.dispatch(&#123; type: 'incrementAsync', amoutn: 10&#125;) 组件中分发Action 在组件中使用this.$store.dispatch('xxx')分发action，或者使用mapAction辅助函数将组件的methods映射为store.dispatch调用。和mapMutation类似 123456789101112import &#123; mapAction &#125; from 'vuex'export default &#123; methods: &#123; ...mapAction([ 'increment', // 将this.increment()映射为this.$store.dispatch('increment') 'incrementBy' // 将this.incrementBy(amount)映射为this.increment.dispatch('increment',amount) ]), ...mapAction([ add: 'increment' //将this.add()映射为this.$store.dispatch('increment') ]) &#125;&#125; Module 由于使用单一状态树，所有的状态会集中到一个较大的对象。当应用变得非常复杂是，store对象就要变得相当臃肿 为了解决这个问题，Vuex允许我们将store分割成模块（module）。每个模块拥有自己的state、mutation、action、getter 12345678910111213141516171819const moduleA = &#123; state: &#123;...&#125;, mutations: &#123;...&#125;, action: &#123;...&#125;, getters: &#123;...&#125;&#125;const moduleA = &#123; state: &#123;...&#125;, mutations: &#123;...&#125;, action: &#123;...&#125;, getters: &#123;...&#125;&#125;const store = new Vuex.Store(&#123; modules: &#123; a: moduleA, b: moduleB &#125;&#125;)store.state.a // -&gt;moduleA 的状态","tags":[{"name":"Vue","slug":"Vue","permalink":"http://haojen.github.io/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"http://haojen.github.io/tags/Vuex/"}]},{"title":"vuex","date":"2019-02-10T16:00:00.000Z","path":"2019/02/11/190211-vuex/","text":"非父子和非兄弟组件传值 配置 &lt;ol&gt; &lt;li&gt;src目录下创建一个vuex的文件夹&lt;/li&gt; &lt;li&gt;vuex 文件夹里面创建一个store.js&lt;/li&gt; &lt;li&gt;安装vuex npm install vuex --save &lt;/li&gt; &lt;li&gt;store.js里面引入vue 引入vuex 并且use 1234567891011121314151617181920import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)/* state在vuex中用于存储数据 */var state=&#123; count:1&#125;/* state在vuex中用于存储数据 */var mutation=&#123; inCount()&#123; ++state.count; &#125;&#125;const store = new Vuex.Store(&#123; state, mutations&#125;)export default store &lt;ol&gt; 组件中使用 &lt;ol&gt; &lt;li&gt;引入store 1import store from '../vuex/store.js' &lt;/li&gt; &lt;li&gt;注册 12345export default &#123; data()&#123;return&#123;&#125;&#125;, store, methods:&#123;&#125;&#125; &lt;/li&gt; &lt;li&gt;获取store中的数据 1this.$store.state.数据 &lt;/li&gt; &lt;li&gt;触发mutation中的方法 1this.commit('inCount') &lt;/li&gt; &lt;/ol&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://haojen.github.io/tags/Vue/"},{"name":"Vuex","slug":"Vuex","permalink":"http://haojen.github.io/tags/Vuex/"}]},{"title":"学习中的优秀资源","date":"2019-02-10T03:24:00.000Z","path":"2019/02/10/190210-优秀资源/","text":"阮一峰的网络日志","tags":[{"name":"学习资源","slug":"学习资源","permalink":"http://haojen.github.io/tags/学习资源/"}]},{"title":"markdown常用语法","date":"2019-02-07T03:24:00.000Z","path":"2019/02/07/190207-markdown/","text":"最近发现我写的博客.md文件里面识别不了html代码了，为了让整个blog看上去美观一点，可读性更高一点，我觉得学习一下markdwon语法 换行 一行结束时输入两个空格，然后回车，接着写内容 图片 ![Alt text](/path/to/img.jpg &quot;optional title&quot;) 叙述： 一个感叹号! 紧接着一个方括号，里面放图片的替代文字，当图片地址活因为其他原因没有显示时，将会显示这个文字 紧接着一个小括号，里面放图片地址 optional title图片标题，当鼠标放于图片上面是，显示的文字（可以不写） 小段代码 两个``符号，将你需要标记的代码放于两符号之间，切换到英文键盘，1键前面的那个键 大段代码 ```bash 大段代码 ``` 块 在文字前面加一个&gt; 这个是个演示的块文字 有序列表 数字+. 内容 .一定要是英文状态的，且它与内容间要有空着 121. 演示12. 演示3 无序列表 + 内容 前面的符号可以使+、-和* ，他们都需要与后面的内容有一个空格 标题 # 内容 有几个# 号表示这是几级标题 反斜杠\\ 当这个符号不需要有特殊含义时，仅仅是一个字符时，我们就可以在这个符号前面加一个反斜杠","tags":[{"name":"markdown","slug":"markdown","permalink":"http://haojen.github.io/tags/markdown/"}]},{"title":"thinkPHP框架安装","date":"2019-01-29T01:38:00.000Z","path":"2019/01/29/190129-thinkPHP框架的安装/","text":"thinkPHP概述 是一个免费开源的、快速、简单的面向对象的轻量级的PHP开发框架，是为了便捷WEB应用开发会和简化应用开发尔诞生的 检测环境 PHP &gt;= 5.4.0 PDO PHP Extension MBString PHP Extension CURL PHP Extension 方法：在一个php页面中 echo phpInfo() 源代码安装 thinkPHP源代码下载 解压文件 将文件拷贝网站的根目录(你自己放项目的目录，也可以不拷贝，直接修改apache里面的项目文件指向) 重命名(按你自己的需要)&lt;/li&gt; 若你在第三不的时候拷贝的，此时就可以访问http://loaclhost/项目名/phblic 注意：Apache的默认端口是80，若该端口没有与其他应用的端口产生冲突，我们未修改端口，我们访问localhost的时候，就不用写80 Composer安装 概念 PHP用来管理依赖关系的工具，类似linux中的yum源 方法 &lt;a href='https://getcomposer.org/download/'&gt;官网下载软件&lt;/a&gt; 解压文件 将文件拷贝网站的根目录(你自己放项目的目录，也可以不拷贝，直接修改apache里面的项目文件指向) 重命名(按你自己的需要) 若你在第三不的时候拷贝的，此时就可以访问http://loaclhost/项目名/phblic 注意：Apache的默认端口是80，若该端口没有与其他应用的端口产生冲突，我们未修改端口，我们访问localhost的时候，就不用写80 git安装 直接从github库里面克隆","tags":[{"name":"git","slug":"git","permalink":"http://haojen.github.io/tags/git/"},{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://haojen.github.io/tags/ThinkPHP/"},{"name":"Composer","slug":"Composer","permalink":"http://haojen.github.io/tags/Composer/"}]},{"title":"在页面中打开链接","date":"2019-01-14T04:46:03.203Z","path":"2019/01/14/190114-打开链接/","text":"在新页面打开链接 超链接 1&lt;a href=\"//www.baidu.com\" title=\"百度\" target=\"_blank\"&gt;百度&lt;/a&gt; js 1window.open = '//www.baidu.com\"' 在当前页打开链接 超链接 1&lt;a href=\"//www.baidu.com\" title=\"百度\" ta&gt;百度&lt;/a&gt; js 1window.loaction.href = '//www.baidu.com\"'","tags":[{"name":"a元素","slug":"a元素","permalink":"http://haojen.github.io/tags/a元素/"},{"name":"网页","slug":"网页","permalink":"http://haojen.github.io/tags/网页/"}]},{"title":"设备像素","date":"2019-01-10T01:30:00.000Z","path":"2019/01/10/190110-设备像素/","text":"概念 css像素（CSS Pixel）：适用于web编程，值得是我们在样式代码中逻辑像素，是一个抽象概念，世纪并不存在 设备独立像素（Device Independent Pixel）:与设备无关的逻辑像素，大四表可以通过程序控制和使用的虚拟像素，是一个总体概念 设备像素（Independent Pixel）：物理像素，涉笔控制显示的最小单位，我们常说的1920*1000像素分辨率就是用的设备像素单位 关系 设备独立像素是包含css像素的大类，所以我们直接讨论设备独立像素和设备像素之间的区别和联系。 pc端--1个独立设备像素=1个设备像素（在100%，未缩放的情况下；如果缩放大200%可以说1个独立设备像素=2个设备像素） 移动端--根据设备不同由较大的差异，根据ppi不同我们可以得到不同的换算关系，标准屏幕（160pi下1个独立设备像素=2个设备像素） ppi(pixel per inch): 表示每英寸所包含的像素点树木，树枝越高，说明屏幕能以更高密度显示图像 计算公式 屏幕分辨率：X✖️Y PPI = √￣（XX+YY）/屏幕尺寸 ppi在120-160之间的手机被归位低密度手机 160-240中密度 240-320高密度 320高密度 dpr(device pixel ratio) 设备像素比，设备像素/设备独立像素，代表设备独立像素到设备像素的转换关系， 获取：window.devicePixelRatio","tags":[{"name":"像素","slug":"像素","permalink":"http://haojen.github.io/tags/像素/"},{"name":"开发","slug":"开发","permalink":"http://haojen.github.io/tags/开发/"}]},{"title":"css3中的resize，user-select属性，多列布局特性，怪异盒子模型，倒影","date":"2019-01-09T01:30:00.000Z","path":"2019/01/09/190119-resize等/","text":"resize 盒子大小的拖动 12resize: both; // 支持宽高拖动resize: none; // 支持狂傲拖动","tags":[{"name":"css3","slug":"css3","permalink":"http://haojen.github.io/tags/css3/"}]},{"title":"微信官方接口","date":"2018-12-23T16:00:00.000Z","path":"2018/12/24/181224-微信官方接口/","text":"对接微信公众号平台 获取微信API借口 看微信|公众平台开发者文档中的接入指南 下载API接口文件 看微信|公众平台开发者文档 解压--&gt;wx_sample.php 复制wx_sample.php到项目（第一层目录），并更名为api.php 确认api.php文件中TOKEN常量的定义，并通过svn上传到BAE 打开微信公众平台的开发者中心 URL：上面自定的网址/api.php (一定要把接口文件放在网址后面) Token：weixin (接口文件中TOKEN的值) 确认无误后点击确认按钮，若失败，再进行提交 通过微信手机将端测试 第一次发消息测试，系统不会任何返回信息，因为接口文件值负责检测 开启自动恢复 修改接口文件：注释掉valid方法，因为默认验证通过后，就会退出 1// $wechatObj-&gt;valid 开启自动回复 1$wechatObj-&gt;response 提交修改的代码，再进行测试 微信官方接口分析 define(&quot;TOKEN&quot;,&quot;weixin&quot;); // 定义TOKEN密钥 $wechatObj = new wechatCallbackapiTest(); // 实例化微信对象","tags":[{"name":"接口","slug":"接口","permalink":"http://haojen.github.io/tags/接口/"},{"name":"微信","slug":"微信","permalink":"http://haojen.github.io/tags/微信/"}]},{"title":"微信平台开发","date":"2018-12-22T16:00:00.000Z","path":"2018/12/23/181223-微信平台开发/","text":"开发者模式 微信公众平台账号 订阅号：个人版用户，每天可以发一条消息 服务号：企业版用户，每月可以群发四条消息 在线虚拟逐句或服务器（SAE云引擎、BAE云引擎、阿里云服务器） Tortoise（SVN客户端软件） 自定义云服务器（BAE） 自定义云平台 http://bce.baidu.com/index.html 登录BAE云引擎 产品服务---&gt; 应用引擎BAE 单击添加部署按钮 名称：任意都可以 类型：根据项目需要（我这儿选择的PHP-web）（一定不要选错) 域名：自定义 执行单元个数：1 执行单元套餐：256 其他的默认 确认无误后，点击确定 第二次确认无误后，点击确认 单击管理控制台 访问我们的域名 域名/index.php 管理BAE云服务器 a. 新建文件夹，并进入 b. 鼠标右键 svn检出操作 百度云里复制SVN/GIT地址 然后根据提示输入用户名和密码（百度的账户和密码） 可以修改index.php文件 鼠标右键通过svn提交代码到百度云 配置自动发布：百度云只能够-&gt;配置文件-&gt;发布设置-&gt;开启自动发布","tags":[{"name":"微信","slug":"微信","permalink":"http://haojen.github.io/tags/微信/"},{"name":"公众号","slug":"公众号","permalink":"http://haojen.github.io/tags/公众号/"}]},{"title":"git使用","date":"2018-12-21T16:00:00.000Z","path":"2018/12/22/181222-git/","text":"mac系统自带有git，我们只需要打开终端，然后输入git系统会有提示，根据提示完成后面的操作，就可以使用git了 git常用语法 创建目录 1mkdir demo 文件创建与编辑 1.创建一个文件 1touch file 2.创建一个文件并进入一般模式 1vi 文件名 也可以vi一个已经存在的文件，进入一般模式 3.一般模式进入插入模式 按i键 4.插入模式进入一般模式 按esc 5.一般模式进入命令模式 依次按 :wq 6.查看文件内容 1cat 文件名 初始化一个git仓库 1.远程仓库地址 1git clone 远程仓库地址 2.在本地文件下 1git init git状态 git的状态分为三种：工作区-&gt;暂存区(索引区)-&gt;版本区 1.查看状态 1git status 当文件名是红色时---工作区 当文件名是绿色时---暂存区 不显示----版本区 2.工作区-&gt;️暂存区 1git add 文件名 1git add . .表示将全部工作区的文件移入暂存区 3.暂存区-&gt;版本区 1git commit -m \"file1提交\" 第一次提交的时候必须写-m和引号中的内容 4.暂存区-&gt;工作区 1git rm --cache 文件名 提交远程仓库 查看本地仓库是否已关联远程仓库 1git remote 2.若没有远程仓库或想提交另一个远程仓库，为当前仓库添加远程仓库 1git remote add 远程仓库别名 url（远程地址） 3.把文件提交到远程仓库 1git push [-u/-f] 远程仓库 本地仓库 [-u/-f]第一次提交时，必须写上其中一个","tags":[{"name":"git","slug":"git","permalink":"http://haojen.github.io/tags/git/"}]},{"title":"两栏布局-右侧自适应","date":"2018-12-20T16:00:00.000Z","path":"2018/12/21/181221-两栏布局/","text":"利用简单的css实现左侧盒子200px定宽，右侧盒子自适应 分析：如果想让两个div在一行内展示，则需要改变div默认的display：block 实现方式：float，position，flex，table, border 结构布局 1234&lt;div class=\"content\"&gt; &lt;div class=\"left\"&gt;1111111&lt;/div&gt; &lt;div class=\"right\"&gt;2222&lt;/div&gt;&lt;/div&gt; 基础样式 123456789101112131415* &#123; padding: 0; margin: 0;&#125;.left &#123; background-color: red; width: 200px; height: 300px;&#125;.right &#123; background-color: #000; height: 300px; color: #fff;&#125; 左侧固定左侧自适应 方法一：浮动（float) 思路：给left添加float:left样式，使其脱离标准文档流，后面元素就可以占据本来left所占据的行，再给右侧的div设置margin-right:200px使两个盒子不重叠。 123456.left &#123; float: left;&#125;.right &#123; margin-left: 200px;&#125; 方法二:浮动和overflow 思路：设置float属性（不为none）时，会创建BFC，再设置overflow（不为visible）时也会产生BFC 1234567.left &#123; float: left; &#125;.right &#123; overflow: auto;&#125; 方法三；positon:absolute或者fixed 1234567left &#123; position: absolute; /*position: fixed;*/&#125;.right &#123; margin-left: 200px;&#125; 方法四；display:flex 123456.content &#123; display: flex;&#125;.right &#123; flex: 1;&#125; 方法五；dispaly:table 1234567.content &#123; display: table; width: 100%;&#125;.left,.right &#123; display: table-cell;&#125; 方法六；box-sizing 123456789101112131415.content &#123; box-sizing: content-box; font-size: 0;&#125;.left,.right &#123; display: inline-block; vertical-align: top; font-size: 14px; box-sizing: border-box;&#125;.right &#123; width: calc(100% - 200px);&#125; 总结 这个问题大的整体思路就是，div是块级元素，当我们不设置它的宽度时，它的宽度就是一行，换句话说此时它的宽度就会随着浏览器的窗口大小而改变，那么我们需要做的工作就是把左侧盒子设置固定的宽度，并让这两个盒子在一行内显示 注解 &lt;span style=&quot;color:red&quot;&gt;box-sizing&lt;/span&gt; &lt;style&gt; table th:first-of-type{ width:100px } &lt;/style&gt; 值 描述 content-box 这是由 CSS2.1 规定的宽度高度行为。&lt;/br&gt;宽度和高度分别应用到元素的内容框.&lt;br&gt;在宽度和高度之外绘制元素的内边距和边框。 boxder-box 为元素设定的宽度和高度决定了元素的边框盒。&lt;/br&gt;就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。&lt;/br&gt;通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的 inherit 规定应从父元素继承 box-sizing 属性的值。 &lt;span style=&quot;color:red&quot;&gt;标准文档流：&lt;/span&gt;一种默认状态，文档流指的是元素排版布局过程中，元素会自动从左往右，从上往下的流式排列。并最终窗体自上而下分成一行行，并在每行中从左至右的顺序排放元素。 &lt;span style=&quot;color:red&quot;&gt;BFC：&lt;/span&gt;块级格式化上下文 (Block Fromatting Context)是按照块级盒子布局的。 W3C对BFC的定义如下： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。","tags":[{"name":"html","slug":"html","permalink":"http://haojen.github.io/tags/html/"},{"name":"两栏布局","slug":"两栏布局","permalink":"http://haojen.github.io/tags/两栏布局/"}]},{"title":"vue强制刷新组件","date":"2018-12-19T16:00:00.000Z","path":"2018/12/20/181220vue强制刷新组件/","text":"问题 分页组件用过的elemntUi中的el-pagination，大体是三层嵌套的关系，第一层页面 &lt;- 子组件 &lt;- el-pagination 最近修改我们项目的样式，和调整一些小bug，然后遇到了一个按条件查询，分页组件的currentPage无法实时刷新的问题， 比如我按'全部'这个条件查询的时候，此时我已经切换到了第四页的内容，然后我切换到按'红包'这个条件查询，查询的结果是第一页的了， 在方法中我已经把currentPage = 1了，但是分页组件的内容仍然没有发生变化，开始以为我在第二层中加入了watch监听currentPage的变化， 但是分页组件仍然没有变化，多次尝试后，我发现当子组件被强制刷新后，currentPage会等于1，于是我就想到了强制刷新的方法 第一层分页组件组件 12345ve-pagination :total=\"total\" :pageSize=\"searchParams.pageSize\" v-if=\"iscurrentPage\" :currentPage=\"currentPage\" @changePage=\"changePage\"/&gt; iscurrentPage:我们用于改变它的值实现强制刷新 强制刷新 强制刷新方法 123456currentPageReset () &#123; this.iscurrentPage = false this.$nextTick(() =&gt; &#123; this.iscurrentPage = true &#125;) &#125; 监听下拉框值的变化 我这儿监听的是一个对象中具体某一个值的变化 1234567891011121314151617181920watch: &#123; 'searchParams.type': &#123; handler (val, oldValue) &#123; if (val === 'RECHARGE') &#123; this.searchLabel = '很抱歉，没有搜索到账户充值的结果' this.currentPageReset() &#125; else if (val === 'RED_PACK') &#123; this.searchLabel = '很抱歉，没有搜索到红包消费的结果' this.currentPageReset() &#125; else if (val === 'RE_RED_PACK') &#123; this.searchLabel = '很抱歉，没有搜索到红包返回的结果' this.currentPageReset() &#125; else &#123; this.searchLabel = '暂无数据' this.currentPageReset() &#125; &#125;, deep: true &#125;&#125;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://haojen.github.io/tags/Vue/"},{"name":"组件","slug":"组件","permalink":"http://haojen.github.io/tags/组件/"}]},{"title":"阿里图标库的使用","date":"2018-12-18T16:00:00.000Z","path":"2018/12/19/181219-阿里图标库使用/","text":"一个项目中，不可避免要用到很多的图标，完全自己做是比较麻烦的，此时我们就可以充分利用网上图标库---如：阿里图标库 阿里图标库 创建一个自己的项目 搜索你需要的图标， 然后加入购物车，点击购物车，添加到自己的项目 回到你需要项目图标页面（图标管理-&gt;我的项目） 界面会提醒你更新代码，点击更新，然后点击复制代码 类名使用 回到我的项目页面 点击 Font class 在需要的地方进行使用 1&lt;i class='iconfont icon-Heartarrow'&gt; iconfont 表示你是用的图标 icon-Heartarrow 表示你使用的具体图标是哪一个（回到图标库中的你的项目，鼠标放在你需要的图标上方，点击复制代码） 伪类使用 拿现有一个的项目距离，我们的项目（vue完整项目） src-&gt;assets-&gt;font-&gt;iconfont.scss 回到项目页，点击 Unicode 点击复制代码，把复制内容放于 iconfont.scss 123456789@font-face &#123;font-family: 'iconfont'; /* project id 1017971 */ src: url('//at.alicdn.com/t/font_1017971_lr076u6w32l.eot'); src: url('//at.alicdn.com/t/font_1017971_lr076u6w32l.eot?#iefix') format('embedded-opentype'), url('//at.alicdn.com/t/font_1017971_lr076u6w32l.woff2') format('woff2'), url('//at.alicdn.com/t/font_1017971_lr076u6w32l.woff') format('woff'), url('//at.alicdn.com/t/font_1017971_lr076u6w32l.ttf') format('truetype'), url('//at.alicdn.com/t/font_1017971_lr076u6w32l.svg#iconfont') format('svg');&#125; 在src-&gt;app.js中引用 1import 'assets/fonts/iconfont.scss' 找到目标图标，鼠标置于改图标之上，点击获取代码 将这个代码做一定的修改，例： --&gt; \\e6b0 将\\e6b0 放于 伪元素的content:'' 的引号中 并在样式中加入font-family:'iconfont'","tags":[{"name":"组件","slug":"组件","permalink":"http://haojen.github.io/tags/组件/"},{"name":"阿里图标库","slug":"阿里图标库","permalink":"http://haojen.github.io/tags/阿里图标库/"},{"name":"类名","slug":"类名","permalink":"http://haojen.github.io/tags/类名/"},{"name":"伪类","slug":"伪类","permalink":"http://haojen.github.io/tags/伪类/"}]},{"title":"git提交代码的步骤","date":"2018-12-17T16:00:00.000Z","path":"2018/12/18/181218-git提交代码/","text":"场景：现在我本地有两个分支，master和cq两个分支 master分支主要用于pull代码和push代码，cq分支主要用于修改代码 查看本地文件的状态 git status 将代码从工作区提交到缓存区 git add . . 表示提交全部修改的文件到缓存区 将文件从缓存区提交到版本去 git commit -m 'ui' '' 中的内容表示你这次修改的是什么，或者修改的目的是什么 切换到master分支 git checkout master 获取远程上的最新代码 git pull origin master 提交前，一定要pull一下，否则将不能提交或者覆盖掉别人修改的代码 origin 表示远程仓库名 master 表示远程分支名 合并本地的cq和master分支 git merge cq 将现在master分支的代码提交到远程master分支 git push origin master 冲突处理 git grep '&lt;&lt;&lt;&lt;&lt;' 找到冲突文件，修改掉冲突，再add、commit、push一下就可以了","tags":[{"name":"git","slug":"git","permalink":"http://haojen.github.io/tags/git/"},{"name":"分支","slug":"分支","permalink":"http://haojen.github.io/tags/分支/"},{"name":"代码提交","slug":"代码提交","permalink":"http://haojen.github.io/tags/代码提交/"}]},{"title":"vue路由","date":"2018-12-09T16:00:00.000Z","path":"2018/12/10/181210-vue路由/","text":"安装 npm install vue-router --save cnpm install vue-router --save 引入 import VueRouter from 'vue-router' Vue.use(VueRouter) 配置路由 创建组件 引入组件 定义路由 （建议复制js） 1234const routes = &#123; &#123;path:'/foo',componet:Foo&#125; &#123;path:'/bar',componet:BAr&#125;&#125; 实例化VueRouter 123cosnt router = new VueRouter(&#123; routes //(缩写) 相当于routes:routes&#125;) 挂载 12345new Vue(&#123; el:'#app', router,&#125;) 使用 动态路由 传值 123const routes = &#123; &#123;path:'/foo/:aid',componet:Foo&#125;&#125; 1&lt;router-link :to=\"'/foo/'+key\"&gt;&#123;&#123;key&#125;&#125; -- &#123;&#123;item&#125;&#125;&lt;/router-link&gt; 获取 this.$route.params 路由get传值 传值 &lt;router-link :to=&quot;'/foo?key='+key&quot;&gt;{{key}} -- {{item}}&lt;/router-link&gt; 获取 this.$route.query 编程式导航 this.$router.push({path:'/content/495'}) 命名路由 配置路由 123const routes = &#123; &#123;path:'/news',componet:News,name:'news'&#125;&#125; 使用 1this.router.push(&#123;name:'news'&#125;) history 模式 12345// 实例化VueRouter时const router = new VueRouter(&#123; mode:&apos;history&apos;, routes&#125;) 子路由 12345678910const routes = &#123; &#123; path:'/user', componet:User, name:'user', children:[ &#123;path:'useradd',component:UserAdd&#125; ] &#125;&#125;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://haojen.github.io/tags/Vue/"},{"name":"路由","slug":"路由","permalink":"http://haojen.github.io/tags/路由/"}]},{"title":"vue组件传值","date":"2018-12-08T16:00:00.000Z","path":"2018/12/09/181209-vue组件传值/","text":"父组件给子组件传值： 1 . 父组件调用子组件的时候 绑定动态属性 &lt;v-head :title='title'&gt;&lt;/v-head&gt; 引号中的title表示父组件中的数据 2 . 在子组件里面通过 props接受父组件传过来的数据 props:[&quot;title&quot;] 3 . 也可以传方法和把整个父组件，方法和上面也一样 非父子组件给子组件传值(事件广播)： 1 . 新建一个js文件 然后引入vue 实例华vue 然后暴露这个实例 import Vue from 'vue' var VueEvent = new Vue () export default VueEvent 2 . 在广播的地方引入刚才定义好的实例 import VueEvent from '地址' 3 . 通过VueEmit.$emit('名称','数据') 4 . 在接受数据的地方通过 VueEmit.$on('名称',function(){}) 父组件主动获取子组件的数据和方法 1 . 调用子组件的时候定义一个ref &lt;v-head ref='head'&gt;&lt;/v-head&gt; 2 . 在父组件里面通过 this.$refs.header.属性 this.$refs.header.方法 父组件主动获取子组件的值 this.$parent.header.属性 this.$parent.header.方法","tags":[{"name":"Vue","slug":"Vue","permalink":"http://haojen.github.io/tags/Vue/"},{"name":"组件","slug":"组件","permalink":"http://haojen.github.io/tags/组件/"}]},{"title":"vue项目小知识","date":"2018-12-07T16:00:00.000Z","path":"2018/12/08/181208-vue小知识/","text":"组件 watch监听对象 每个监听都是有handler的，也可以不写；监听对象时，必须写上deep 1234567watch: &#123; user: &#123; hander(newValue,oldValue) =&gt; &#123; console.log('user被修改了') &#125;, deep: true &#125;&#125; 获取组件中data中的值： vm.name 或者 vm.$data.name&lt;/li&gt; 获取组件中data中的值： vm.name 或者 vm.$data.name &lt;/li&gt; 获取绑定的元素：vm.$el 设置样式：vm.$el.style.color = red &lt;/li&gt; 获取自定义属性：vm.$options.name &lt;/li&gt; 获取添加了ref属性的元素：vm.$refs.namebox &lt;/li&gt; 手动挂载vue实例：vue.$mount('#app') 或者 new Vue({}).$mount('#app') &lt;/li&gt; 挂载时调用某个函数获取某一个值： 1getValue () &#123; this.nextTick(function()&#123; console.log(this.$refs.input.value)&#125;)&#125; 给data中的user对象新增age属性： this.$set(this.user,'age',22) &lt;/li&gt; 删除data中的user对象age属性： this.$set(this.user,'age') &lt;/li&gt; 缓存数据： localStorage.setItem('key',JSON.stringfify(this.list)) &lt;/li&gt; 获取缓存数据： var list = JSON.parse(localStorage.getItem('list')) &lt;/li&gt; 请求数据： 安装vue-resource模块 记得加上--save main.js引入 vue-resource import VueResource from 'vue-resouce' Vue.use(VueRe souce) html元素 动态绑定类名： 1&lt;li v-for=\"(item, key) in items\" :class=\"&#123;'red':key===1&#125;\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;","tags":[{"name":"Vue","slug":"Vue","permalink":"http://haojen.github.io/tags/Vue/"},{"name":"组件","slug":"组件","permalink":"http://haojen.github.io/tags/组件/"}]},{"title":"搭建vue开发环境","date":"2018-12-07T16:00:00.000Z","path":"2018/12/08/181208-vue项目搭建/","text":"1 . 必须安装nodejs 2 . 搭vue开发环境，安装vue的脚手架工具 官方命令工具 npm install --g vue-cli 3 . 创建项目 vue init weback vue-demo01 cd vue-demo01 cnpm install / npm install npm run dev 4 . 另外一种创建项目的方式 vue init webpack-simple vue-demo02 cd vue-demo02 cnpm install / npm install npm run dev vue的模版里面 所有的内容要被一个根结点包含起来","tags":[{"name":"Vue","slug":"Vue","permalink":"http://haojen.github.io/tags/Vue/"},{"name":"npm","slug":"npm","permalink":"http://haojen.github.io/tags/npm/"},{"name":"Vue-cli","slug":"Vue-cli","permalink":"http://haojen.github.io/tags/Vue-cli/"}]},{"title":"易盾验证","date":"2018-12-05T16:00:00.000Z","path":"2018/12/06/181206易盾验证/","text":"易盾是网易云旗下的一个产品 验证码三种模式：float(发式)、embed(嵌入式)、popup(弹出式) 兼容性 IE7+、Chrome、Firefox、Safari、Opera、主流手机浏览器、iOS 及 Android上的内嵌Webview 使用 开始使用 引入初始化js 1&lt;script src=\"//cstaticdun.126.net/load.min.js\"&gt;&lt;/script&gt; 调用初始化函数 1initNECaptcha(config, onload, onerror) 123456789101112// initNECaptcha为全局函数，可直接调用initNECaptcha(&#123; // config对象，参数配置 captchaId: '从易盾申请的captchaId', element: '#captcha', mode: 'float', width: '320px'&#125;, function (instance) &#123; // 初始化成功后得到验证实例instance，可以调用实例的方法&#125;, function (err) &#123; // 初始化失败后触发该函数，err对象描述当前错误信息&#125;) 参数配置 这里指初始化时传入的config对象，即调用初始化函数initNECaptcha时传入的第一个参数。智能验证码设置参数有些不同，详见表格下方特别说明。 参数 参数类型 必填 默认 说明 captchaId string 是 无 验证码id element string 否 * HTMLElement mode string 否 pc-&gt;float、移动端-&gt;popup 验证码模式 protocol string 否 与永无网站的协议一致 验证码传输数据使用的网络协议，可选：http、https width number 否 auto 宽度 lang string 否 zh-CN 验证码语言选项。支持&quot;zh-CN&quot;、&quot;en&quot;，即简体中文和英文 onReady function 否 无 NECaptcha所有工作准备就绪，用户可以使用验证码时触发该回调。具体使用见完整示例 onVertify function 否 无 验证码验证结束回调函数。具体使用见完整示例 实例方法 这里指initNECaptcha初始化成功，onload触发时传入的实例的方法。 refresh：刷新验证码，获取新的验证信息 destroy：销毁当前实例 popUp：当验证码是常规验证码并且mode为&quot;popup&quot;时，可调用该实例方法弹出验证码进行验证 123initNECaptcha(config, function onload (instance) &#123; // 可在此处调用实例方法&#125;, onerror) form表单 1234567891011121314151617181920&lt;form action=\"/login\" method=\"post\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"用户名\"&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"密码\"&gt; &lt;input type=\"hidden\" name=\"captchaId\" value=\"从易盾申请的captchaId\"&gt; &lt;div id=\"captcha\"&gt;&lt;/div&gt; &lt;!-- 验证码容器元素 --&gt; &lt;button type=\"submit\"&gt;登录&lt;/button&gt;&lt;/form&gt;&lt;script src=\"//cstaticdun.126.net/load.min.js\"&gt;&lt;/script&gt;&lt;!-- 初始化JS --&gt;&lt;script&gt; initNECaptcha(&#123; captchaId: '从易盾申请的captchaId', element: '#captcha', mode: 'float', width: 320 &#125;, function onload (instance) &#123; // 初始化成功后，用户输入对应用户名和密码，以及完成验证后，直接点击登录按钮即可 &#125;, function onerror (err) &#123; // 验证码初始化失败处理逻辑，例如：提示用户点击按钮重新初始化 &#125;)&lt;script&gt; onVerify 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div class=\"form-container\"&gt; &lt;input type=\"text\" name=\"username\" id=\"username\" placeholder=\"用户名\"&gt; &lt;input type=\"password\" name=\"password\" id=\"password\" placeholder=\"密码\"&gt; &lt;div id=\"captcha\"&gt;&lt;/div&gt; &lt;!-- 验证码容器元素 --&gt; 登录&lt;/div&gt;&lt;script src=\"//cstaticdun.126.net/load.min.js\"&gt;&lt;/script&gt;&lt;!-- 初始化JS --&gt;&lt;script&gt; initNECaptcha(&#123; captchaId: '从易盾申请的captchaId', element: '#captcha', mode: 'float', width: 320, onReady: function (instance) &#123; // 验证码一切准备就绪，此时可正常使用验证码的相关功能 &#125;, onVerify: function (err, data) &#123; /** * 第一个参数是err（Error的实例），验证失败才有err对象 * 第二个参数是data对象，验证成功后的相关信息，data数据结构为key-value，如下： * &#123; * validate: 'xxxxx' // 二次验证信息 * &#125; */ // 点击登录按钮后可调用服务端接口，以下为伪代码，仅作示例用 ajax('/login', &#123; captchaId: '从易盾申请的captchaId', username: $('#username').val(), password: $('#password').val(), validate: data.validate &#125;, function onsuccess (data) &#123; // 登录成功后，相关处理逻辑 &#125;) &#125; &#125;, function onload (instance) &#123; // 初始化成功 &#125;, function onerror (err) &#123; // 验证码初始化失败处理逻辑，例如：提示用户点击按钮重新初始化 &#125;)&lt;/script&gt; popup 1234567891011121314151617181920&lt;button id=\"j-popup\"&gt;点击弹出验证码&lt;/button&gt;&lt;div id=\"captcha\"&gt;&lt;/div&gt;&lt;script charset=\"UTF-8\" type=\"text/javascript\" src=\"http://cstaticdun.126.net/load.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var captchaIns; initNECaptcha(&#123; element: '#captcha', captchaId: '从易盾申请的captchaId', mode: 'popup', width: '320px' &#125;, function (instance) &#123; // 初始化成功后得到验证实例instance，可以调用实例的方法 captchaIns = instance &#125;, function (err) &#123; // 初始化失败后触发该函数，err对象描述当前错误信息 &#125;) // 监听button的点击事件，弹出验证码 document.getElementById('j-popup').addEventListener('click', function () &#123; captchaIns.popUp()&lt;/scripr&gt; 注意：onload和onReady的区别： onload和onReady触发时，均会返回验证码的实例，即传入的第一个参数。二者触发时机有所不同，onload触发时，初始化函数结束和完成实例的生成，注意这并不代表验证码是可用的（比如验证码相关背景图片和信息并没有加载），此方法只触发一次。onReady触发时，说明验证码准备就绪（比如背景图片等信息均已加载），在popup模式下，每次弹出均会触发onReady，其他模式下onReady只触发一次。 文章来自：&lt;a href='https://blog.csdn.net/w97531/article/details/80448239'&gt;网站验证码WEB前端接入实例&lt;/a&gt;","tags":[{"name":"易盾验证","slug":"易盾验证","permalink":"http://haojen.github.io/tags/易盾验证/"}]},{"title":"全屏与居中","date":"2018-12-04T16:00:00.000Z","path":"2018/12/05/181205-全屏与居中/","text":"这边文章主要记录我今天看代码和练习代码关于盒子布局的收获 结构 12345678&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt; &lt;div class=\"l-content\"&gt;我是左边的内容&lt;/div&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;div class=\"r-content\"&gt;我是右边的小可爱&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 基础样式 如果我们想让一个盒子水平或者垂直方向居中，我们一般都会给它设置宽度和高度 123456789101112131415161718192021222324252627* &#123;margin: 0;padding: 0;&#125;.wrap &#123;height: 100%; background-color: #00c47d; clear: both; min-hight: 300px;&#125;.left &#123; background-color: #ffff00; float: left; width: 50%; position: relative;&#125;.l-content &#123; background-color: #00acec; width: 200px; height: 200px;&#125;.right &#123; background-color: #2e7ac4; float: right; width: 50%;&#125;.r-content &#123; background-color: red; height: 200px; width: 200px;&#125; 垂直方向全屏 目前我看到的方法答题就只有这一种，首先设置body和html的高度为100%，再设置盒子的高度 12html,body &#123;height:100%&#125;.wrap &#123;height:10%&#125; 水平居中 margin 较为简单就是这种，要注意的是，当position的值不为static时，这种方法不会生效 123.l-content &#123; margin: 0 auto&#125; position 12345.l-content &#123; position: absolute; left: 50%; margin-left: -100px; // 这个盒子宽度的一半&#125; 垂直居中 postion postion完成大致地定位，margin调整居中 12345.l-content &#123; position: absolute; top: 50%; margin-top: -100px; // 这个盒子宽度的一半&#125; margin 1234567.r-content &#123; position: absolute; top: 0; bottom: 0; margin: auto 0; max-height: 200px;&#125; transform 12345678.r-content &#123; background-color: red; height: 200px; width: 200px; position: absolute; top: 50%; transform: translate(0, -50%);&#125; flex 对父亲盒子使用弹性布局 方法一 1234.right &#123; display: flex; align-items: center;&#125; 方法二 12345.right &#123; display: flex; flex-direction: column; justify-content: center;&#125;","tags":[{"name":"盒子","slug":"盒子","permalink":"http://haojen.github.io/tags/盒子/"},{"name":"全屏","slug":"全屏","permalink":"http://haojen.github.io/tags/全屏/"},{"name":"居中","slug":"居中","permalink":"http://haojen.github.io/tags/居中/"}]},{"title":"ES6特性","date":"2018-12-03T16:00:00.000Z","path":"2018/12/04/181214-ES6/","text":"ES6简介 ECMScript6简称ES6，是JavaScript语言的下一代标砖，以及在2015年6余额发布。 ECMScript和JavaScript的关系：前者是后者的语法规格，后者是前者的一种实现 新特性 let、const let定义的变量不会被变量提升，const定义的常量不能被修改 const定义了一个对象，对象的属性是可以被修改的，例：student.name = &quot;cc&quot; import、export 123456789101112// 全部导入import people from './example'// 将整个模块当作单一对象进行导入，该模块的所有导出都会作为对象的属性存在import * as example from \"./example.js\"console.log(example.name)console.log(example.getName())// 导入部分，引入非 default 时，使用花括号import &#123;name, age&#125; from './example'// 导出默认, 有且只有一个默认export default App// 部分导出export class App extend Component &#123;&#125;; class、extends、super 123456789101112131415161718class Animal &#123; constructor() &#123; this.type = 'animal'; &#125; says(say) &#123; console.log(this.type + ' says ' + say); &#125;&#125;let animal = new Animal();animal.says('hello'); //animal says helloclass Cat extends Animal &#123; constructor() &#123; super(); this.type = 'cat'; &#125;&#125;let cat = new Cat();cat.says('hello'); //cat says hello 首先定义了一个&quot;类&quot;，有constructor构造方法，this关键字则代表实例对象。换句话来说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的 class之间可以通过extends实现继承。如实例中Cat类，通过extends关键字，继承了Animal类的所有属性和fnagfa。 super关键字，它指代父亲的实例（即父亲的this对象）。子类必须在constructor方法中调用super方法，否则实例时会报错。因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用，子类就得不到this对象 ES6的继承机制，实质是看创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 箭头函数 函数的快捷写法。不需要function来创建函数，省略retrun，继承当前上下文的this 123456789101112// ES5var arr1 = [1, 2, 3];var newArr1 = arr1.map(function(x) &#123; return x + 1;&#125;);// ES6let newArr2 = arr1.map((x) =&gt; &#123; x + 1&#125;);// ES6 函数有且只有一个参数是，可以省略括号，函数中有且只有一个表达式可以省略&#123;&#125;let newArr2 = arr1.map(x =&gt; x + 1 ); tempalte string(模版字符串) 第一个用途：字符串拼接。将表达式嵌入字符串中进行拼接，语法 hello ${变量} 123456// es5var name1 = \"bai\";console.log('hello ' + name1);// es6const name2 = \"ming\";console.log(`hello $&#123;name2&#125;`); 第二个用途：多行字符串拼接 1234567// es5var msg = \"Hi \\man!\";// es6const template = `&lt;div&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;`; destructing (解构) 简化数组和对象中信息的提取 12345678let people2 = &#123; name: 'ming', age: 20, color: ['red', 'blue']&#125;let &#123; name, age &#125; = people2;let [first, second] = people2.color;console.log(`$&#123;name&#125;----$&#123;age&#125;----$&#123;first&#125;`); default 函数默认参数 123456789// ES5 给函数定义参数默认值function foo(num) &#123; num = num || 200; return num;&#125;// ES6function foo(num = 200) &#123; return num;&#125; rest arguments （rest参数） 1234function foo(x, y, ...rest) &#123; return ((x + y) * rest.length);&#125;foo(1, 2, 'hello', true, 7); // 9 Spread Operator （展开运算符） 第一个用途：组装数组 123let color = ['red', 'yellow'];let colorful = [...color, 'green', 'blue'];console.log(colorful); // [\"red\", \"yellow\", \"green\", \"blue\"] 第二个用途：获取数组除了某几项的其他项 123let num = [1, 3, 5, 7, 9];let [first, second, ...rest] = num;console.log(rest); // [5, 7, 9] 对象 1234567891011121314/// ES5function people(name, age) &#123; return &#123; name: name, age: age &#125;;&#125;// ES6function people(name, age) &#123; return &#123; name, age &#125;;&#125; 另外：Object.assign() ES6 对象提供了Object.assign()这个方法来实现浅复制。Object.assign()可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{} 用法1：合并对象 123456var first = &#123; name: \"Bob\" &#125;;var last = &#123; lastName: \"Smith\" &#125;;var person = Object.assign(first, last);console.log(person);// Output:// &#123; name: \"Bob\", lastName: \"Smith\" &#125; 用法2：克隆对象 12var obj = &#123; person: \"Bob Smith\"&#125;;var clone = Object.assign(&#123;&#125;, obj); Promise 用同步的方式写一步代码 12345// 发起异步请求fetch('/api/todos').then(res =&gt; res.json()).then(data =&gt; (&#123; data &#125;)).catch(err =&gt; (&#123; err &#125;)); Generators 生成器（generator）是能返回一个迭代器的函数 生成器也是一种函数，最直观的表现就是比普通的function多一个*号，在其函数体内可以使用yield关键字，函数会在每个yield后暂停 如：银行取号排队办理业务 迭代器：调用一个generator时，它将返回一个迭代器对象。这个跌打器对象拥有一个叫做next的方法帮组你重启generator函数并得到了下一个值。nenxt方法不返回值，它返回的对象具有两个属性：done和value。calue是你获得的值，done用来表明你的generator是否已停止提供值。 1234567891011// 生成器function *createIterator() &#123; yield 1; yield 2; yield 3;&#125;// 生成器能像正规函数那样被调用，但会返回一个迭代器let iterator = createIterator();console.log(iterator.next().value); // 1console.log(iterator.next().value); // 2console.log(iterator.next().value); // 3 参考文献：https://www.cnblogs.com/fangsmile/p/7081194.html","tags":[{"name":"es6","slug":"es6","permalink":"http://haojen.github.io/tags/es6/"}]},{"title":"单选框和复选框","date":"2018-12-03T16:00:00.000Z","path":"2018/12/04/181204-input/","text":"input的功能可以说是非常强大了，他的属性不同，呈现的效果是完全不一样的 单选框 123&lt;label&gt;性别：&lt;label&gt;男：&lt;input type='radio' name='gender'&gt;女：&lt;input type='radio' name='gender'&gt; 复选框 12345&lt;label&gt;爱好：&lt;label&gt;篮球：&lt;input type='checkbox' name='hobby' value=\"1\"&gt;足球：&lt;input type='checkbox' name='hobby' value=\"2\"&gt;跑步：&lt;input type='checkbox' name='hobby' value=\"3\"&gt;跳舞：&lt;input type='checkbox' name='hobby' value=\"4\"&gt; 属性 属性 值及功能 type radio:单选框 checkbox:复选框 value 提交数据到后台的值 checked 当设置 checked=true或者&quot;checked&quot; 时，该选项被默认选中 disabled true：禁用 false(默认):非禁用 checkbox视觉上忧伤三种状态： checked(选中)、unchecked(未选中)、indeterminate(不确定的) element中的input：http://element-cn.eleme.io/#/zh-CN/component/input","tags":[{"name":"input","slug":"input","permalink":"http://haojen.github.io/tags/input/"}]},{"title":"flex布局","date":"2018-12-02T16:00:00.000Z","path":"2018/12/03/181203-flex/","text":"flex是一个非常好用的布局样式，一行内两端对齐，只有中间有间隙等的布局 弹性盒子 display:flex flex为复合属性，且必须配合父元素display:flex使用。 以下6个属性设置在子元素上： flex-grow：放大比例 flex-shrink：缩小比例 flex-basis：伸缩基准值 flex：前面三者的缩写 order：排列顺序 align：单个元素对齐方式","tags":[{"name":"html","slug":"html","permalink":"http://haojen.github.io/tags/html/"}]},{"title":"vue中前端接口的调用两种方式","date":"2018-12-01T16:00:00.000Z","path":"2018/12/02/181202-vue中前接口调用/","text":"在做实际项目中，我遇到的两种调用api的方式 第一种方式 接口文件 文件名：a-manger.js 文件地址：src/api/a-manger.js 文件内容： 1234567891011121314import utils from 'src/utils'// utils文件夹里面放我们需要用到的ajax相关的文件const AManger = &#123; queryName (userid) &#123; return utils.ajax(&#123; method: 'post' //请求方式：post和get url: '接口地址' params: userid // 注意 这儿传入的是 userid = 值，es6简写 // 多个参数是，params就是一个对象，比如 params: &#123;id: id,name: name&#125; &#125;) &#125;&#125;export default aManger &lt;span style='color:red&gt;注意:&lt;/span&gt; 文件末尾一定要写上export defauly aManger 使用文件 文件名：b.vue 文件内容： 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt;此处内容省略&lt;template&gt;&lt;script&gt; import aManger from 'src/api/a-manger' export default &#123; name: 'b', data()&#123; return &#123; name: '' &#125; &#125;, methods: &#123; f (userid) &#123; aManger.queryName(userid).then((res) =&gt; &#123; // res就是后台返回的结果 // 一定要判断返回的结果 if (res.code === 200)&#123; this.name = res.data.name &#125; &#125;) &#125; &#125; &#125;&lt;script&gt;&lt;span style='color:red&gt;注意:&lt;/span&gt; 如果在调用f函数时，想要立即拿到name的值，就需要使用对f以及调用这个地方aynsc和await## 第二种方式### 接口文件文件名：d-manger.js文件地址：src/api/d-manger.js文件内容：```bashexport default &#123; GET_ACTIVITY_INFO: '接口地址'&#125; &lt;span style='color:red&gt;注意:&lt;/span&gt; 冒号前的名字要全部大写 使用文件 文件名：b.vue 文件内容： &lt;template&gt;此处内容省略&lt;template&gt; &lt;script&gt; import dManger from 'src/api/d-manger' export default { name: 'b', data(){ return { name: '' } }, methods: { f () { this.$get(dManger.GET_ACTIVITY_INFO,{ activityId: this.activityId }).then((res) =&gt; { if (res.code === 200){ this.activityId = res.data } }) } } } &lt;script&gt; &lt;span style='color:red&gt;注意:&lt;/span&gt; 如果在调用f函数时，想要立即拿到name的值，就需要使用对f以及调用这个地方aynsc和await","tags":[{"name":"Vue","slug":"Vue","permalink":"http://haojen.github.io/tags/Vue/"},{"name":"api","slug":"api","permalink":"http://haojen.github.io/tags/api/"},{"name":"接口","slug":"接口","permalink":"http://haojen.github.io/tags/接口/"}]},{"title":"vue扫码支付功能的实现","date":"2018-11-30T16:00:00.000Z","path":"2018/12/01/181201-支付流程解析/","text":"生成二维码，用户扫码支付后，然后跳转到指定的的页面 过程解析 用户点击充值按钮 弹出一个对话框 用户充值金额，点击下一步，在这部中执行的操作有两个请求， 函数a：请求根据用户填写的金额，拿到订单号； 函数b：请求根据订单号拿到我们需要的二维码； 弹出第二个对话框，第二个对话框的内容有充值的金额和二维码，充值金额在这个框中仍然可以修改， 在用户修改完成，点击保存的时候，再调用函数a和b 系统通过函数b，检测到用户扫码成功后，跳转到支付成功页面，并调用显示余额 函数a 函数a中只需要往后台发送一个请求，就是请求订单号 函数b 函数b中主要有两个请求， 第一个请求：根据订单号获得二维码 第二个请求：往后台发送用户信息，并监控用户是否以及扫码支付","tags":[{"name":"Vue","slug":"Vue","permalink":"http://haojen.github.io/tags/Vue/"},{"name":"接口","slug":"接口","permalink":"http://haojen.github.io/tags/接口/"},{"name":"扫码","slug":"扫码","permalink":"http://haojen.github.io/tags/扫码/"}]},{"title":"javascript中offsetWidth、clientWidth、width、scrollWidth、clientX、screenX、offsetX、pageX","date":"2018-11-28T16:00:00.000Z","path":"2018/11/29/181119-client和offset/","text":"盒子模型：content、padding、border、margin w表示宽度 h表示高度 width和height offsetWidth :返回元素的宽度（contentW+paddingW+borderW） offsetHeight :返回元素的高度（contentH+paddingH+borderH） clientWidth :返回元素的宽度（contentW+paddingW） clientHeight :返回元素的高度（contentH+paddingH） style.width :返回元素的宽度（contentW） style.height :返回元素的高度（contentH） scrollWidth :返回元素的宽度（包括元素宽度、内边距和溢出尺寸，不包括边框和外边距），无溢出的情况，与clientWidth相同） scrollHeigh :返回元素的高度（包括元素高度、内边距和溢出尺寸，不包括边框和外边距），无溢出的情况，与clientHeight相同） style.width 返回的是字符串，如28px，offsetWidth返回的是数值28； style.width/style.height与scrollWidth/scrollHeight是可读写的属性，clientWidth/clientHeight与offsetWidth/offsetHeight是只读属性 style.width的值需要事先定义，否则取到的值为空。而且必须要定义在html里(内联样式)，如果定义在css里，style.height的值仍然为空，但元素偏移有效；而offsetWidth则仍能取到。 top与left offsetTop :返回元素的上外缘距离最近采用定位父元素内壁的距离，如果父元素中没有采用定位的，则是获取上外边缘距离文档内壁的距离。所谓的定位就是position属性值为relative、absolute或者fixed。返回值是一个整数，单位是像素。此属性是只读的。 offsetLeft :此属性和offsetTop的原理是一样的，只不过方位不同，这里就不多介绍了。 scrollLeft :此属性可以获取或者设置对象的最左边到对象在当前窗口显示的范围内的左边的距离，也就是元素被滚动条向左拉动的距离。返回值是一个整数，单位是像素。此属性是可读写的。 scrollTop :此属性可以获取或者设置对象的最顶部到对象在当前窗口显示的范围内的顶边的距离，也就是元素滚动条被向下拉动的距离。返回值是一个整数，单位是像素。此属性是可读写的。 X和Y 当鼠标事件发生时（不管是onclick，还是omousemove，onmouseover等） clientX :鼠标相对于浏览器（这里说的是浏览器的有效区域）左上角x轴的坐标； 不随滚动条滚动而改变； clientY :鼠标相对于浏览器（这里说的是浏览器的有效区域）左上角y轴的坐标； 不随滚动条滚动而改变； pageX :鼠标相对于浏览器（这里说的是浏览器的有效区域）左上角x轴的坐标； 随滚动条滚动而改变； pageY :鼠标相对于浏览器（这里说的是浏览器的有效区域）左上角y轴的坐标； 随滚动条滚动而改变； screenX :鼠标相对于显示器屏幕左上角x轴的坐标； screenY :鼠标相对于显示器屏幕左上角y轴的坐标； offsetX :鼠标相对于事件源左上角X轴的坐标 offsetY :鼠标相对于事件源左上角Y轴的坐标","tags":[{"name":"html","slug":"html","permalink":"http://haojen.github.io/tags/html/"}]},{"title":"正则表达式","date":"2018-11-28T16:00:00.000Z","path":"2018/11/29/181129-正则表达式/","text":"正则表达式有一些普通字符和一些元字符组成。普通字符包括大小写的字母和数字，而元字符则具有特殊含义。 匹配有两种概念：一种时匹配字符，一种是匹配位置 元字符 元字符 描述 \\ 简单理解就是转义字符。将下一个字符标记符，或一个向后引用，或者一个八进制转义符。例如：&quot;\\n&quot;匹配\\n，&quot;\\n&quot;匹配换行符 ^ 行首 $ 行尾 * 前面子表达式表达式任意次。例如：zo能匹配z、zo、zoo。等价于{0,} + 前面子表达式表达式大于等于1次。例如：zo能匹配zo、zoo。等价于{1,} ? 前面子表达式表达式0次或1次。例如：do(es)能匹配do、does。等价于{0,1} {n} 匹配确定的n次，n为非负整数。例如：o{2}能匹配food中的两个o。 {n,} 至少匹配的n次，n为非负整数。例如：o{2}能匹配fooooood中的所有的o。 {n,m} 匹配n至m次，n为非负整数。例如：o{1,3}能匹配fooooood中的前三个o为1组，后三个o为一组。 [xyz] 匹配xyz任意一个 [^xyz] 匹配未包含的任意字符 [a-z] 字母范围。 [^a-z] 非字母范围。 \\b 匹配单词的边界，单词与空格间的位置。例如：er\\b可以匹配到her中的er，不能匹配herb中的 \\B 匹配非单词的边界。 \\cx 匹配有x说明的控制符，x必须是[a-Z]中的一个。例如：\\cM匹配的时control—M或者回车符 \\d 匹配数字，等价于[0-9] \\D 匹配非数字，等价于[^0-9] \\f 换页，等价于\\x0c和\\cL \\n 换行，等价于\\x0a和\\cJ \\r 回车，等价于\\x0d和\\cM \\d 任意不可见字符，包括空格、制表符、换行符等等，等价于[\\f\\n\\t\\r\\v] \\D 任意可见字符，包括空格、制表符、换行符等等，等价于[^\\f\\n\\t\\r\\v] *、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 通过在 *、+ 或 ? 限定符之后放置 ?，该表达式从&quot;贪心&quot;表达式转换为&quot;非贪心&quot;表达式或者最小匹配。","tags":[{"name":"正则","slug":"正则","permalink":"http://haojen.github.io/tags/正则/"}]},{"title":"Mac下xcrun: error: invalid active developer path问题解决方法","date":"2018-11-28T01:30:00.000Z","path":"2018/11/28/181128Mac下xcrun/","text":"引言：Mac下xcrun: error: invalid active developer path问题解决方法 问题起源 在mac 下，克隆某个项目 1git clone xxxx 报错 1xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 问题解决 终端输入，然后根据提示操作 1xcode-select --install","tags":[{"name":"mac","slug":"mac","permalink":"http://haojen.github.io/tags/mac/"},{"name":"xcrun","slug":"xcrun","permalink":"http://haojen.github.io/tags/xcrun/"}]},{"title":"vue","date":"2018-11-22T16:00:00.000Z","path":"2018/11/23/181123-vue/","text":"v-if 判断 v-else 与v-if一起使用，两个标签必须紧挨着 v-for 绑定一个数组来渲染一个项目列表 v-for=&quot;item in items&quot; v-on 添加一个事件监听器 v-on:click=&quot;remove&quot; v-model 数据双向绑定 组件化应用构建 组建本质上是一个拥有预定义选项的一个Vue实例 创建一个组建 1234//定义名为todo-item的新组件Vue,component('todo-item',&#123; template：'&lt;li&gt;这是一个组件&lt;/li&gt;'&#125;) 1234//使用&lt;ol&gt; &lt;todo-item&gt;&lt;/todo-item&gt;&lt;/ol&gt; Vue 实例 创建vue实例 1234567var data = &#123; a:1&#125;var vue = new Vue (&#123; el:\"#app\" //vue作用的范围，必须写 data: data&#125;) 生命周期函数 12345678beforeCreate: function()&#123;&#125;created: function()&#123;&#125;beforeMounted: function()&#123;&#125;mounted: function()&#123;&#125;beforeUpdate: function()&#123;&#125;updated: function()&#123;&#125;beforeDdestory: function()&#123;&#125;destoryed: function()&#123;&#125; 模版语法 插值 Mustache语法（双大括号） 1&lt;span&gt;Message:&#123;&#123;msg&#125;&#125;&lt;/span&gt; 12//使用v-once指令 ，当msg发生变化时，span里面的内容也不会改变&lt;span v-once&gt;这个将不会改变:&#123;&#123;msg&#125;&#125;&lt;/span&gt; 原始HTML 1&lt;p&gt;Message:&lt;span v-html=\"msg\"&gt;&lt;/span&gt;&lt;/p&gt; text 1&lt;p&gt;Message:&lt;span v-text=\"msg\"&gt;&lt;/span&gt;&lt;/p&gt; 1和3不能识别msg中html语法，2会对msg中的内容进行编译 ###使用javascript表达式 例：NaN 指令 指令（Directive）是带有v-前缀的特俗特性。 参数 v-bind响应式更新HTML特性 缩写：:href 1&lt;a v-bind:href=\"url\"&gt;链接&lt;/a&gt; v-on 用于监听DOM事件 缩写： @click 1&lt;a v-on:click=\"do\"&gt;链接&lt;/a&gt; 修饰符 修饰符（Modifiers）是以半角句号.指明的特殊后缀 1&lt;form v-on:submit.prevent=\"submit\"&gt;……&lt;/form&gt; 计算属性 基础例子 1234&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"&#123;&#123; message &#125;&#125;\"&lt;/p&gt; &lt;p&gt;Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"&lt;/p&gt;&lt;/div&gt; 123456789101112var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125; 监听器 当需要在数据变化时执行异步或开销较大的操作时 绑定HTML Class 对象语法 12&lt;div v-bind:class=\"active\"&gt;绑定一个类名&lt;/div&gt;&lt;div v-bind:class=\"&#123; active: isActive，static：isStatic &#125;\"&gt;绑定多个类名&lt;/div&gt; active 这个 class 存在与否将取决于数据属性 isActive 的 值。 数组语法 对象语法 1&lt;div v-bind:class=\"[ active: isActive，static：isStatic ]\"&gt;绑定多个类名&lt;/div&gt; 用在组件 声明组件时 123Vue.component('my-component', &#123; template: '&lt;p class=\"foo bar\"&gt;Hi&lt;/p&gt;'&#125;) 使用时添加一些class 1&lt;my-component class=\"baz boo\"&gt;&lt;/my-component&gt; html渲染结果为 1&lt;p class=\"foo bar active\"&gt;Hi&lt;/p&gt; 绑定内联样式 对象语法 v-bind:style 12&lt;div v-bind:style=\"&#123;color:activeColor,fontSize:fontSize+'px'&#125;\"&gt;&lt;/div&gt;&lt;div v-bind:style=\"styleObject\"&gt;&lt;/div&gt; 绑定对象的数据语法 123456data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; 条件渲染 v-if 12345&lt;template v-if=\"ok\"&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;p&gt;p 1&lt;/p&gt; &lt;p&gt;p 2&lt;/p&gt;&lt;/template&gt; v-else元素必须紧跟在带v-if或者v-else-if的元素后面，否则它将不会被识别 key管理可复用的元素 v-show 根据条件展示元素 1&lt;h1 v-show=\"ok\"&gt;Hello!&lt;/h1&gt; 带有v-show的元素始终会被渲染并保存在dom中 &lt;span style=&quot;color:red&quot;&gt;注意&lt;/span&gt;:v-show不支持&lt;template&gt;元素，也不支持v-else v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 列表渲染 v-for =&quot;item in items&quot; v-for =&quot;item of items&quot; items可以时对象也可以是数组 v-for=&quot;(value, key) in object&quot; v-for=&quot;(value, key, index) in object&quot; v-for 取整数 123&lt;div&gt; &lt;span v-for=\"n in 10\"&gt;&#123;&#123;n&#125;&#125;&lt;/span&gt;&lt;/div&gt; 结果是：1 2 3 4 5 6 7 8 9 处于同一节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。 数组更新检测 变异方法 push() 从后插入 pop() 从后弹出 shift() 从前弹出 unshift() 从前插入 splice() 截取 sort() 排序 reverse() 反转 替换数组 filter() concat() slice() 事件处理 监听事件 v-on 指令监听Dom事件，并在出发时运行一些javascript代码 123&lt;div id=\"app\"&gt; &lt;button v-on:click=\"counter += 1\"&gt;add 1 &lt;/button&gt;&lt;/div&gt; 事件处理方法 v-on 绑定事件 1&lt;button v-on:click=\"greet\"&gt;greet&lt;button&gt; 事件修饰符 stop 阻止事件继续传递 prevent 阻止事件再重载页面 capture self once passive v-on:click.prevent.self会阻止所有的点击 v-on:click.self.prevent会阻止对元素自身的点击 按键修饰符 按键别名 enter tab delete esc space up down left right 通过全局config.keyCode对象自定义按键修饰符别名 Vue.config.keyCodes.f1 = 112 组件的组织 组件的注册类型：全局注册和局部注册 Vue.component是全局注册 通过Prop向子组件传递数据 1234Vue.component('blog-post',&#123; props: ['title'], template: '&lt;h3&gt;&lt;&#123;&#123; title &#125;&#125;/h3&gt;'&#125;) 123&lt;blog-post title=\"My journey with Vue\"&gt;&lt;/blog-post&gt;&lt;blog-post title=\"Blogging with Vue\"&gt;&lt;/blog-post&gt;&lt;blog-post title=\"Why Vue is so fun\"&gt;&lt;/blog-post&gt; 复选框 input -- checkbox 单个复选框,绑定到布尔值 12&lt;input type=\"checkbox\" id=\"\"checkbox\" v-model=\"checked\"&gt;&lt;label for=\"checkbox\"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; 多个复选框，绑定到同一个数组 12345678910&lt;div id='example'&gt; &lt;input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\"&gt; &lt;label for=\"jack\"&gt;Jack&lt;/label&gt; &lt;input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\"&gt; &lt;label for=\"john\"&gt;John&lt;/label&gt; &lt;input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\"&gt; &lt;label for=\"mike\"&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-3', data: &#123; checkedNames: [] &#125;&#125;) 单选按钮 input -- radio 123456789&lt;div id=\"example\"&gt; &lt;input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\"&gt; &lt;label for=\"one\"&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\"&gt; &lt;label for=\"two\"&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example', data: &#123; picked: '' &#125;&#125;) 选择框 select option 单选时： 123456789&lt;div id=\"example-5\"&gt; &lt;select v-model=\"selected\"&gt; &lt;option disabled value=\"\"&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: 'example-5', data: &#123; selected: '' &#125;&#125;) 多选时： 123456789&lt;div id=\"example-6\"&gt; &lt;select v-model=\"selected\" multiple style=\"width: 50px;\"&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-6', data: &#123; selected: [] &#125;&#125;) 组件基础 基本示例 12345678Vue.component('button-counter',&#123; data: function()&#123; return &#123; count:0 &#125; &#125;, template: '&lt;button v-on:click=\"count++\"&gt;you clicked me &#123;&#123;count&#125;&#125; times&lt;/button&gt;'&#125; 123&lt;div id=\"components-demo\"&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 123new Vue(&#123; el:'#components-demo'&#125;) 组件组册 子组件中的data必须是一个function，且必须return一个对象，这个对象中可以放数据 组件名大小写 使用kebab-case(短横线分割) 例：my-component-name 使用PascalCase(驼峰式) 例：MyComponentName 全局注册 Vue.component('name',{}) 局部注册 12var ComponentA = &#123; /* ... */ &#125;var ComponentB = &#123; /* ... */ &#125; 1234567new Vue(&#123; el: '#app', components: &#123; 'component-a': ComponentA, 'component-b': ComponentB &#125;&#125;) 模块系统 在模块系统中局部注册 123456789import ComponentA from './ComponentA'import ComponentC from './ComponentC'export default &#123; components: &#123; ComponentA, ComponentC &#125;,&#125; prop 数据检测 Vue.component('my-component', { props: { // 基础的类型检查 (`null` 匹配任何类型) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: { type: String, required: true }, // 带有默认值的数字 propD: { type: Number, default: 100 }, // 带有默认值的对象 propE: { type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () { return { message: 'hello' } } }, // 自定义验证函数 propF: { validator: function (value) { // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 } } } }) ### 类型检查 type 可以是下列原生构造函数中的一个： String Number Boolean Array Object Date Function Symbol &lt;span style=&quot;color:red,font-size:18px&quot;&gt;不懂的地方：&lt;/span&gt;自定义组件的v-model、sync修饰符 ## 插槽 Vue 实现了一套内容分发的 API，这套 API 基于当前的 Web Components 规范草案，将 &lt;slot&gt; 元素作为承载分发内容的出口。","tags":[{"name":"vue","slug":"vue","permalink":"http://haojen.github.io/tags/vue/"}]},{"title":"positon、display、float","date":"2018-11-19T16:00:00.000Z","path":"2018/11/20/181120-pos_dis_float/","text":"display属性规定元素生成框的类型。 none-缺省值（用于隐藏元素，元素会消失于视界和文档流中）， block-块级元素， inline-block-行内块级元素。 position属性规定元素的定位类型，常用于布局。 static-默认：元素出现在正常文档流中（此时不受top、left、right、bottom、z-index等属性影响）； absolute-绝对定位：脱离文档流，相对于它第一个非static父元素进行定； fixed-固定定位：相对于浏览器窗口进行定位；relative生成相对定位的元素，相对于其正常文档流中的位置进行定位，简单来说就是相对于浏览器窗口进行定位，例如：固定导航。 float属性 定义一个元素浮动方向，最初用于图像使文本环绕，现在是一种布局方式。不论浮动元素本身是何种框类型，浮动后会生成一个块级框。 三者关系 如果'display'设置为'none'，用户端必须忽略掉'position'和'float'。在这种情况下，元素不产生框。 否则，'position'设置为'absolute'或'fixed'，'display'设置为'block'且'float'设置为'none'。框的位置将由'top'，'right'，'bottom'和'left'属性和该框的包含块确定。 否则，如果'float'的值不是'none'，'display'设置为'block'并且该框浮动。 否则，应用指定的其它'display'属性。 即如果'position'设置为'absolute'或'fixed'且‘float’的值不为‘none’，display的值就会被设置为‘block’，所以设置display: inline; float: left;等同于float:left，display:inline 的属性并未生效。因为用户端会忽略掉对’display‘的设置。float:left和display:inline-block当然是不等同的。 position:absolute和float会隐式的改变display类型，不论之前是什么类型的元素（display:none除外），只要设置了position:absolute或float，都会让元素以display:inline-block的方式显示，可以设置长宽，默认宽度并不占满父元素，就算是显示的设置display:inline或display:block，仍然无效。 float在IE6下的双倍边距bug就是利用添加display:inline来解决的 注意一点的是，position:relative并不能够隐式的改变display的类型","tags":[{"name":"html","slug":"html","permalink":"http://haojen.github.io/tags/html/"},{"name":"NFC","slug":"NFC","permalink":"http://haojen.github.io/tags/NFC/"}]}]