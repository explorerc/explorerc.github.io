[{"title":"thinkPHP框架安装","date":"2019-01-29T01:38:00.000Z","path":"2019/01/29/thinkPHP框架的安装/","text":"thinkPHP概述 是一个免费开源的、快速、简单的面向对象的轻量级的PHP开发框架，是为了便捷WEB应用开发会和简化应用开发尔诞生的 检测环境 &lt;ol&gt; &lt;li&gt;PHP &gt;= 5.4.0 &lt;/li&gt; &lt;li&gt;PDO PHP Extension &lt;/li&gt; &lt;li&gt;MBString PHP Extension &lt;/li&gt; &lt;li&gt;CURL PHP Extension&lt;/li&gt; &lt;/ol&gt; 方法：在一个php页面中 echo phpInfo() 源代码安装 &lt;ol&gt; &lt;li&gt;&lt;a href='http://www.thinkphp.cn/down.html'&gt;thinkPHP源代码下载&lt;/a&gt;&lt;/li&gt; &lt;li&gt;解压文件&lt;/li&gt; &lt;li&gt;将文件拷贝网站的根目录(你自己放项目的目录，也可以不拷贝，直接修改apache里面的项目文件指向)&lt;/li&gt; &lt;li&gt;重命名(按你自己的需要)&lt;/li&gt; &lt;li&gt;若你在第三不的时候拷贝的，此时就可以访问http://loaclhost/项目名/phblic&lt;/li&gt; &lt;/ol&gt; &lt;span style='color:red'&gt;注意：&lt;span&gt;Apache的默认端口是80，若该端口没有与其他应用的端口产生冲突，我们未修改端口， 我们访问localhost的时候，就不用写80 Composer安装 概念 PHP用来管理依赖关系的工具，类似linux中的yum源 方法 &lt;ol&gt; &lt;li&gt;&lt;a href='https://getcomposer.org/download/'&gt;官网下载软件&lt;/a&gt;&lt;/li&gt; &lt;li&gt;解压文件&lt;/li&gt; &lt;li&gt;将文件拷贝网站的根目录(你自己放项目的目录，也可以不拷贝，直接修改apache里面的项目文件指向)&lt;/li&gt; &lt;li&gt;重命名(按你自己的需要)&lt;/li&gt; &lt;li&gt;若你在第三不的时候拷贝的，此时就可以访问http://loaclhost/项目名/phblic&lt;/li&gt; &lt;span style='color:red'&gt;注意：&lt;span&gt;Apache的默认端口是80，若该端口没有与其他应用的端口产生冲突，我们未修改端口，我们访问localhost的时候，就不用写80 &lt;/ol&gt; git安装","tags":[{"name":"ThinkPHP","slug":"ThinkPHP","permalink":"http://haojen.github.io/tags/ThinkPHP/"},{"name":"git","slug":"git","permalink":"http://haojen.github.io/tags/git/"},{"name":"Composer","slug":"Composer","permalink":"http://haojen.github.io/tags/Composer/"}]},{"title":"在页面中打开链接","date":"2019-01-14T04:46:03.203Z","path":"2019/01/14/在新页面中打开链接/","text":"在新页面打开链接 超链接 1&lt;a href=\"//www.baidu.com\" title=\"百度\" target=\"_blank\"&gt;百度&lt;/a&gt; js 1window.open = '//www.baidu.com\"' 在当前页打开链接 超链接 1&lt;a href=\"//www.baidu.com\" title=\"百度\" ta&gt;百度&lt;/a&gt; js 1window.loaction.href = '//www.baidu.com\"'","tags":[{"name":"a元素","slug":"a元素","permalink":"http://haojen.github.io/tags/a元素/"},{"name":"网页","slug":"网页","permalink":"http://haojen.github.io/tags/网页/"}]},{"title":"设备像素","date":"2019-01-10T01:30:00.000Z","path":"2019/01/10/设备像素/","text":"概念 css像素（CSS Pixel）：适用于web编程，值得是我们在样式代码中逻辑像素，是一个抽象概念，世纪并不存在 设备独立像素（Device Independent Pixel）:与设备无关的逻辑像素，大四表可以通过程序控制和使用的虚拟像素，是一个总体概念 设备像素（Independent Pixel）：物理像素，涉笔控制显示的最小单位，我们常说的1920*1000像素分辨率就是用的设备像素单位 关系 设备独立像素是包含css像素的大类，所以我们直接讨论设备独立像素和设备像素之间的区别和联系。 pc端--1个独立设备像素=1个设备像素（在100%，未缩放的情况下；如果缩放大200%可以说1个独立设备像素=2个设备像素） 移动端--根据设备不同由较大的差异，根据ppi不同我们可以得到不同的换算关系，标准屏幕（160pi下1个独立设备像素=2个设备像素） ppi(pixel per inch): 表示每英寸所包含的像素点树木，树枝越高，说明屏幕能以更高密度显示图像 计算公式 屏幕分辨率：X✖️Y PPI = √￣（XX+YY）/屏幕尺寸 ppi在120-160之间的手机被归位低密度手机 160-240中密度 240-320高密度 320高密度 dpr(device pixel ratio) 设备像素比，设备像素/设备独立像素，代表设备独立像素到设备像素的转换关系， 获取：window.devicePixelRatio","tags":[{"name":"像素","slug":"像素","permalink":"http://haojen.github.io/tags/像素/"},{"name":"开发","slug":"开发","permalink":"http://haojen.github.io/tags/开发/"}]},{"title":"css3中的resize，user-select属性，多列布局特性，怪异盒子模型，倒影","date":"2019-01-09T01:30:00.000Z","path":"2019/01/09/css3-resize等/","text":"resize 盒子大小的拖动 12resize: both; // 支持宽高拖动resize: none; // 支持狂傲拖动","tags":[{"name":"css3","slug":"css3","permalink":"http://haojen.github.io/tags/css3/"},{"name":"resize","slug":"resize","permalink":"http://haojen.github.io/tags/resize/"}]},{"title":"微信官方接口","date":"2018-12-22T02:55:47.319Z","path":"2018/12/22/微信官方接口/","text":"对接微信公众号平台 1）获取微信API借口 看微信|公众平台开发者文档中的接入指南 2）下载API接口文件 看微信|公众平台开发者文档 解压--&gt;wx_sample.php 3）复制wx_sample.php到项目（第一层目录），并更名为api.php 4）确认api.php文件中TOKEN常量的定义，并通过svn上传到BAE 5）打开微信公众平台的开发者中心 URL：上面自定的网址/api.php (一定要把接口文件放在网址后面) Token：weixin (接口文件中TOKEN的值) 确认无误后点击确认按钮，若失败，再进行提交 6）通过微信手机将端测试 第一次发消息测试，系统不会任何返回信息，因为接口文件值负责检测 7）开启自动恢复 a. 修改接口文件：注释掉valid方法，因为默认验证通过后，就会退出 1// $wechatObj-&gt;valid b. 开启自动回复 1$wechatObj-&gt;response 提交修改的代码，再进行测试 微信官方接口分析 define(&quot;TOKEN&quot;,&quot;weixin&quot;); // 定义TOKEN密钥 $wechatObj = new wechatCallbackapiTest(); // 实例化微信对象","tags":[]},{"title":"微信平台开发","date":"2018-12-22T02:28:47.037Z","path":"2018/12/22/微信平台开发/","text":"开发者模式 微信公众平台账号 订阅号：个人版用户，每天可以发一条消息 服务号：企业版用户，每月可以群发四条消息 在线虚拟逐句或服务器（SAE云引擎、BAE云引擎、阿里云服务器） Tortoise（SVN客户端软件） 开发者模式原理 &lt;img src='../../../../images/post_img/wechat_yuanli.png'&gt; 自定义云服务器（BAE） 自定义云平台 http://bce.baidu.com/index.html 登录BAE云引擎 产品服务---&gt; 应用引擎BAE 单击添加部署按钮 名称：任意都可以 类型：根据项目需要（我这儿选择的PHP-web）（一定不要选错) 域名：自定义 执行单元个数：1 执行单元套餐：256 其他的默认 确认无误后，点击确定 第二次确认无误后，点击确认 单击管理控制台 访问我们的域名 域名/index.php 管理BAE云服务器 a. 新建文件夹，并进入 b. 鼠标右键 svn检出操作 百度云里复制SVN/GIT地址 然后根据提示输入用户名和密码（百度的账户和密码） 可以修改index.php文件 鼠标右键通过svn提交代码到百度云 配置自动发布：百度云只能够-&gt;配置文件-&gt;发布设置-&gt;开启自动发布","tags":[]},{"title":"vue强制刷新组件","date":"2018-12-20T10:34:14.398Z","path":"2018/12/20/vue强制刷新组件/","text":"问题 分页组件用过的elemntUi中的el-pagination，大体是三层嵌套的关系，第一层页面 &lt;- 子组件 &lt;- el-pagination 最近修改我们项目的样式，和调整一些小bug，然后遇到了一个按条件查询，分页组件的currentPage无法实时刷新的问题， 比如我按'全部'这个条件查询的时候，此时我已经切换到了第四页的内容，然后我切换到按'红包'这个条件查询，查询的结果是第一页的了， 在方法中我已经把currentPage = 1了，但是分页组件的内容仍然没有发生变化，开始以为我在第二层中加入了watch监听currentPage的变化， 但是分页组件仍然没有变化，多次尝试后，我发现当子组件被强制刷新后，currentPage会等于1，于是我就想到了强制刷新的方法 第一层分页组件组件 12345ve-pagination :total=\"total\" :pageSize=\"searchParams.pageSize\" v-if=\"iscurrentPage\" :currentPage=\"currentPage\" @changePage=\"changePage\"/&gt; iscurrentPage:我们用于改变它的值实现强制刷新 强制刷新 强制刷新方法 123456currentPageReset () &#123; this.iscurrentPage = false this.$nextTick(() =&gt; &#123; this.iscurrentPage = true &#125;) &#125; 监听下拉框值的变化 我这儿监听的是一个对象中具体某一个值的变化 1234567891011121314151617181920watch: &#123; 'searchParams.type': &#123; handler (val, oldValue) &#123; if (val === 'RECHARGE') &#123; this.searchLabel = '很抱歉，没有搜索到账户充值的结果' this.currentPageReset() &#125; else if (val === 'RED_PACK') &#123; this.searchLabel = '很抱歉，没有搜索到红包消费的结果' this.currentPageReset() &#125; else if (val === 'RE_RED_PACK') &#123; this.searchLabel = '很抱歉，没有搜索到红包返回的结果' this.currentPageReset() &#125; else &#123; this.searchLabel = '暂无数据' this.currentPageReset() &#125; &#125;, deep: true &#125;&#125;","tags":[]},{"title":"阿里图标库的使用","date":"2018-12-19T07:00:10.315Z","path":"2018/12/19/阿里图标库使用/","text":"场景：我是以及再一个项目组中了，然后我要在伪元素中使用项目组中的图标 找到目标图标，鼠标置于改图标之上，点击获取代码 将这个代码做一定的修改，例： --&gt; \\e6b0 将\\e6b0 放于 伪元素的content:'' 的引号中 并在样式中加入font-family:'iconfont'","tags":[]},{"title":"git提交代码的步骤","date":"2018-12-19T06:45:49.223Z","path":"2018/12/19/git提交代码的步骤/","text":"场景：现在我本地有两个分支，master和cq两个分支 master分支主要用于pull代码和push代码，cq分支主要用于修改代码 查看本地文件的状态 git status 将代码从工作区提交到缓存区 git add . . 表示提交全部修改的文件到缓存区 将文件从缓存区提交到版本去 git commit -m 'ui' '' 中的内容表示你这次修改的是什么，或者修改的目的是什么 切换到master分支 git checkout master 获取远程上的最新代码 git pull origin master 提交前，一定要pull一下，否则将不能提交或者覆盖掉别人修改的代码 origin 表示远程仓库名 master 表示远程分支名 合并本地的cq和master分支 git merge cq 将现在master分支的代码提交到远程master分支 git push origin master 冲突处理 git grep '&lt;&lt;&lt;&lt;&lt;' 找到冲突文件，修改掉冲突，再add、commit、push一下就可以了","tags":[]},{"title":"vuex","date":"2018-12-09T09:39:59.256Z","path":"2018/12/09/vuex/","text":"非父子和非兄弟组件传值 配置 &lt;ol&gt; &lt;li&gt;src目录下创建一个vuex的文件夹&lt;/li&gt; &lt;li&gt;vuex 文件夹里面创建一个store.js&lt;/li&gt; &lt;li&gt;安装vuex npm install vuex --save &lt;/li&gt; &lt;li&gt;store.js里面引入vue 引入vuex 并且use 1234567891011121314151617181920import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)/* state在vuex中用于存储数据 */var state=&#123; count:1&#125;/* state在vuex中用于存储数据 */var mutation=&#123; inCount()&#123; ++state.count; &#125;&#125;const store = new Vuex.Store(&#123; state, mutations&#125;)export default store &lt;ol&gt; 组件中使用 &lt;ol&gt; &lt;li&gt;引入store 1import store from '../vuex/store.js' &lt;/li&gt; &lt;li&gt;注册 12345export default &#123; data()&#123;return&#123;&#125;&#125;, store, methods:&#123;&#125;&#125; &lt;/li&gt; &lt;li&gt;获取store中的数据 1this.$store.state.数据 &lt;/li&gt; &lt;li&gt;触发mutation中的方法 1this.commit('inCount') &lt;/li&gt; &lt;/ol&gt;","tags":[]},{"title":"vue路由","date":"2018-12-09T08:43:00.721Z","path":"2018/12/09/vue路由/","text":"安装 12npm install vue-router --savecnpm install vue-router --save 引入并use import VueRouter from 'vue-router' Vue.use(VueRouter) 配置路由 1 . 创建组件 引入组件 2 . 定义路由 （建议复制js） 1234const routes = &#123; &#123;path:'/foo',componet:Foo&#125; &#123;path:'/bar',componet:BAr&#125;&#125; 3 . 实例花VueRouter 123cosnt router = new VueRouter(&#123; routes //(缩写) 相当于routes:routes&#125;) 4 . 挂载 12345new Vue(&#123; el:'#app', router,&#125;) 5 . 使用 动态路由 传值 123const routes = &#123; &#123;path:'/foo/:aid',componet:Foo&#125;&#125; 1&lt;router-link :to=\"'/foo/'+key\"&gt;&#123;&#123;key&#125;&#125; -- &#123;&#123;item&#125;&#125;&lt;/router-link&gt; 获取 1this.$route.params 路由get传值 传值 1&lt;router-link :to=\"'/foo?key='+key\"&gt;&#123;&#123;key&#125;&#125; -- &#123;&#123;item&#125;&#125;&lt;/router-link&gt; 获取 1this.$route.query 编程式导航 this.$router.push({path:'/content/495'}) 命名路由 配置路由 123const routes = &#123; &#123;path:'/news',componet:News,name:'news'&#125;&#125; 使用 1this.router.push(&#123;name:'news'&#125;) history 模式 12345// 实例化VueRouter时const router = new VueRouter(&#123; mode:&apos;history&apos;, routes&#125;) 子路由 12345678910const routes = &#123; &#123; path:'/user', componet:User, name:'user', children:[ &#123;path:'useradd',component:UserAdd&#125; ] &#125;&#125;","tags":[]},{"title":"vue项目","date":"2018-12-09T01:20:59.564Z","path":"2018/12/09/vue小知识/","text":"组件 &lt;ol&gt; &lt;li&gt;watch监听对象 每个监听都是有handler的，也可以不写；监听对象时，必须写上deep 1234567watch: &#123; user: &#123; hander(newValue,oldValue) =&gt; &#123; console.log('user被修改了') &#125;, deep: true &#125;&#125; &lt;/li&gt; &lt;li&gt;获取组件中data中的值： vm.name 或者 vm.$data.name&lt;/li&gt; &lt;li&gt;获取组件中data中的值： vm.name 或者 vm.$data.name &lt;/li&gt; &lt;li&gt;获取绑定的元素：vm.$el 设置样式：vm.$el.style.color = red &lt;/li&gt; &lt;li&gt;获取自定义属性：vm.$options.name &lt;/li&gt; &lt;li&gt;获取添加了ref属性的元素：vm.$refs.namebox &lt;/li&gt; &lt;li&gt;手动挂载vue实例：vue.$mount('#app') 或者 new Vue({}).$mount('#app') &lt;/li&gt; &lt;li&gt;挂载时调用某个函数获取某一个值： 1getValue () &#123; this.nextTick(function()&#123; console.log(this.$refs.input.value)&#125;)&#125; &lt;/li&gt; &lt;li&gt; 给data中的user对象新增age属性： this.$set(this.user,'age',22) &lt;/li&gt; &lt;li&gt; 删除data中的user对象age属性： this.$set(this.user,'age') &lt;/li&gt; &lt;li&gt; 缓存数据： localStorage.setItem('key',JSON.stringfify(this.list)) &lt;/li&gt; &lt;li&gt; 获取缓存数据： var list = JSON.parse(localStorage.getItem('list')) &lt;/li&gt; &lt;li&gt; 请求数据： 1 . 安装vue-resource模块 记得加上--save 2 . main.js引入 vue-resource import VueResource from 'vue-resouce' 3 . Vue.use(VueRe souce) &lt;/li&gt; &lt;/ol&gt; html元素 动态绑定类名： 1&lt;li v-for=\"(item, key) in items\" :class=\"&#123;'red':key===1&#125;\"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;","tags":[]},{"title":"vue组件传值","date":"2018-12-09T01:18:55.807Z","path":"2018/12/09/vue组件传值/","text":"父组件给子组件传值： 1 . 父组件调用子组件的时候 绑定动态属性 &lt;v-head :title='title'&gt;&lt;/v-head&gt; 引号中的title表示父组件中的数据 2 . 在子组件里面通过 props接受父组件传过来的数据 props:[&quot;title&quot;] 3 . 也可以传方法和把整个父组件，方法和上面也一样 非父子组件给子组件传值(事件广播)： 1 . 新建一个js文件 然后引入vue 实例华vue 然后暴露这个实例 import Vue from 'vue' var VueEvent = new Vue () export default VueEvent 2 . 在广播的地方引入刚才定义好的实例 import VueEvent from '地址' 3 . 通过VueEmit.$emit('名称','数据') 4 . 在接受数据的地方通过 VueEmit.$on('名称',function(){}) 父组件主动获取子组件的数据和方法 1 . 调用子组件的时候定义一个ref &lt;v-head ref='head'&gt;&lt;/v-head&gt; 2 . 在父组件里面通过 this.$refs.header.属性 this.$refs.header.方法 父组件主动获取子组件的值 this.$parent.header.属性 this.$parent.header.方法","tags":[]},{"title":"搭建vue开发环境","date":"2018-12-08T01:05:24.265Z","path":"2018/12/08/vue项目搭建/","text":"1 . 必须安装nodejs 2 . 搭vue开发环境，安装vue的脚手架工具 官方命令工具 npm install --g vue-cli 3 . 创建项目 vue init weback vue-demo01 cd vue-demo01 cnpm install / npm install npm run dev 4 . 另外一种创建项目的方式 vue init webpack-simple vue-demo02 cd vue-demo02 cnpm install / npm install npm run dev vue的模版里面 所有的内容要被一个根结点包含起来","tags":[]},{"title":"易盾验证","date":"2018-12-06T09:07:59.308Z","path":"2018/12/06/易盾验证/","text":"易盾是网易云旗下的一个产品 验证码三种模式：float(发式)、embed(嵌入式)、popup(弹出式) 兼容性 IE7+、Chrome、Firefox、Safari、Opera、主流手机浏览器、iOS 及 Android上的内嵌Webview 使用 开始使用 引入初始化js 1&lt;script src=\"//cstaticdun.126.net/load.min.js\"&gt;&lt;/script&gt; 调用初始化函数 1initNECaptcha(config, onload, onerror) 123456789101112// initNECaptcha为全局函数，可直接调用initNECaptcha(&#123; // config对象，参数配置 captchaId: '从易盾申请的captchaId', element: '#captcha', mode: 'float', width: '320px'&#125;, function (instance) &#123; // 初始化成功后得到验证实例instance，可以调用实例的方法&#125;, function (err) &#123; // 初始化失败后触发该函数，err对象描述当前错误信息&#125;) 参数配置 这里指初始化时传入的config对象，即调用初始化函数initNECaptcha时传入的第一个参数。智能验证码设置参数有些不同，详见表格下方特别说明。 参数 参数类型 必填 默认 说明 captchaId string 是 无 验证码id element string 否 * HTMLElement mode string 否 pc-&gt;float、移动端-&gt;popup 验证码模式 protocol string 否 与永无网站的协议一致 验证码传输数据使用的网络协议，可选：http、https width number 否 auto 宽度 lang string 否 zh-CN 验证码语言选项。支持&quot;zh-CN&quot;、&quot;en&quot;，即简体中文和英文 onReady function 否 无 NECaptcha所有工作准备就绪，用户可以使用验证码时触发该回调。具体使用见完整示例 onVertify function 否 无 验证码验证结束回调函数。具体使用见完整示例 实例方法 这里指initNECaptcha初始化成功，onload触发时传入的实例的方法。 refresh：刷新验证码，获取新的验证信息 destroy：销毁当前实例 popUp：当验证码是常规验证码并且mode为&quot;popup&quot;时，可调用该实例方法弹出验证码进行验证 123initNECaptcha(config, function onload (instance) &#123; // 可在此处调用实例方法&#125;, onerror) form表单 1234567891011121314151617181920&lt;form action=\"/login\" method=\"post\"&gt; &lt;input type=\"text\" name=\"username\" placeholder=\"用户名\"&gt; &lt;input type=\"password\" name=\"password\" placeholder=\"密码\"&gt; &lt;input type=\"hidden\" name=\"captchaId\" value=\"从易盾申请的captchaId\"&gt; &lt;div id=\"captcha\"&gt;&lt;/div&gt; &lt;!-- 验证码容器元素 --&gt; &lt;button type=\"submit\"&gt;登录&lt;/button&gt;&lt;/form&gt;&lt;script src=\"//cstaticdun.126.net/load.min.js\"&gt;&lt;/script&gt;&lt;!-- 初始化JS --&gt;&lt;script&gt; initNECaptcha(&#123; captchaId: '从易盾申请的captchaId', element: '#captcha', mode: 'float', width: 320 &#125;, function onload (instance) &#123; // 初始化成功后，用户输入对应用户名和密码，以及完成验证后，直接点击登录按钮即可 &#125;, function onerror (err) &#123; // 验证码初始化失败处理逻辑，例如：提示用户点击按钮重新初始化 &#125;)&lt;script&gt; onVerify 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div class=\"form-container\"&gt; &lt;input type=\"text\" name=\"username\" id=\"username\" placeholder=\"用户名\"&gt; &lt;input type=\"password\" name=\"password\" id=\"password\" placeholder=\"密码\"&gt; &lt;div id=\"captcha\"&gt;&lt;/div&gt; &lt;!-- 验证码容器元素 --&gt; 登录&lt;/div&gt;&lt;script src=\"//cstaticdun.126.net/load.min.js\"&gt;&lt;/script&gt;&lt;!-- 初始化JS --&gt;&lt;script&gt; initNECaptcha(&#123; captchaId: '从易盾申请的captchaId', element: '#captcha', mode: 'float', width: 320, onReady: function (instance) &#123; // 验证码一切准备就绪，此时可正常使用验证码的相关功能 &#125;, onVerify: function (err, data) &#123; /** * 第一个参数是err（Error的实例），验证失败才有err对象 * 第二个参数是data对象，验证成功后的相关信息，data数据结构为key-value，如下： * &#123; * validate: 'xxxxx' // 二次验证信息 * &#125; */ // 点击登录按钮后可调用服务端接口，以下为伪代码，仅作示例用 ajax('/login', &#123; captchaId: '从易盾申请的captchaId', username: $('#username').val(), password: $('#password').val(), validate: data.validate &#125;, function onsuccess (data) &#123; // 登录成功后，相关处理逻辑 &#125;) &#125; &#125;, function onload (instance) &#123; // 初始化成功 &#125;, function onerror (err) &#123; // 验证码初始化失败处理逻辑，例如：提示用户点击按钮重新初始化 &#125;)&lt;/script&gt; popup 1234567891011121314151617181920&lt;button id=\"j-popup\"&gt;点击弹出验证码&lt;/button&gt;&lt;div id=\"captcha\"&gt;&lt;/div&gt;&lt;script charset=\"UTF-8\" type=\"text/javascript\" src=\"http://cstaticdun.126.net/load.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var captchaIns; initNECaptcha(&#123; element: '#captcha', captchaId: '从易盾申请的captchaId', mode: 'popup', width: '320px' &#125;, function (instance) &#123; // 初始化成功后得到验证实例instance，可以调用实例的方法 captchaIns = instance &#125;, function (err) &#123; // 初始化失败后触发该函数，err对象描述当前错误信息 &#125;) // 监听button的点击事件，弹出验证码 document.getElementById('j-popup').addEventListener('click', function () &#123; captchaIns.popUp()&lt;/scripr&gt; 注意：onload和onReady的区别： onload和onReady触发时，均会返回验证码的实例，即传入的第一个参数。二者触发时机有所不同，onload触发时，初始化函数结束和完成实例的生成，注意这并不代表验证码是可用的（比如验证码相关背景图片和信息并没有加载），此方法只触发一次。onReady触发时，说明验证码准备就绪（比如背景图片等信息均已加载），在popup模式下，每次弹出均会触发onReady，其他模式下onReady只触发一次。 文章来自：&lt;a href='https://blog.csdn.net/w97531/article/details/80448239'&gt;网站验证码WEB前端接入实例&lt;/a&gt;","tags":[]},{"title":"全屏与居中","date":"2018-12-05T14:13:32.802Z","path":"2018/12/05/全屏与居中/","text":"这边文章主要记录我今天看代码和练习代码关于盒子布局的收获 结构 12345678&lt;div class=\"wrap\"&gt; &lt;div class=\"left\"&gt; &lt;div class=\"l-content\"&gt;我是左边的内容&lt;/div&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;div class=\"r-content\"&gt;我是右边的小可爱&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 基础样式 如果我们想让一个盒子水平或者垂直方向居中，我们一般都会给它设置宽度和高度 123456789101112131415161718192021222324252627* &#123;margin: 0;padding: 0;&#125;.wrap &#123;height: 100%; background-color: #00c47d; clear: both; min-hight: 300px;&#125;.left &#123; background-color: #ffff00; float: left; width: 50%; position: relative;&#125;.l-content &#123; background-color: #00acec; width: 200px; height: 200px;&#125;.right &#123; background-color: #2e7ac4; float: right; width: 50%;&#125;.r-content &#123; background-color: red; height: 200px; width: 200px;&#125; 垂直方向全屏 目前我看到的方法答题就只有这一种，首先设置body和html的高度为100%，再设置盒子的高度 12html,body &#123;height:100%&#125;.wrap &#123;height:10%&#125; 水平居中 margin 较为简单就是这种，要注意的是，当position的值不为static时，这种方法不会生效 123.l-content &#123; margin: 0 auto&#125; position 12345.l-content &#123; position: absolute; left: 50%; margin-left: -100px; // 这个盒子宽度的一半&#125; 垂直居中 postion postion完成大致地定位，margin调整居中 12345.l-content &#123; position: absolute; top: 50%; margin-top: -100px; // 这个盒子宽度的一半&#125; margin 1234567.r-content &#123; position: absolute; top: 0; bottom: 0; margin: auto 0; max-height: 200px;&#125; transform 12345678.r-content &#123; background-color: red; height: 200px; width: 200px; position: absolute; top: 50%; transform: translate(0, -50%);&#125; flex 对父亲盒子使用弹性布局 方法一 1234.right &#123; display: flex; align-items: center;&#125; 方法二 12345.right &#123; display: flex; flex-direction: column; justify-content: center;&#125;","tags":[]},{"title":"ES6特性","date":"2018-12-04T08:56:12.402Z","path":"2018/12/04/ES6/","text":"ES6简介 ECMScript6简称ES6，是JavaScript语言的下一代标砖，以及在2015年6余额发布。 ECMScript和JavaScript的关系：前者是后者的语法规格，后者是前者的一种实现 新特性 let、const let定义的变量不会被变量提升，const定义的常量不能被修改 const定义了一个对象，对象的属性是可以被修改的，例：student.name = &quot;cc&quot; import、export 123456789101112// 全部导入import people from './example'// 将整个模块当作单一对象进行导入，该模块的所有导出都会作为对象的属性存在import * as example from \"./example.js\"console.log(example.name)console.log(example.getName())// 导入部分，引入非 default 时，使用花括号import &#123;name, age&#125; from './example'// 导出默认, 有且只有一个默认export default App// 部分导出export class App extend Component &#123;&#125;; class、extends、super 123456789101112131415161718class Animal &#123; constructor() &#123; this.type = 'animal'; &#125; says(say) &#123; console.log(this.type + ' says ' + say); &#125;&#125;let animal = new Animal();animal.says('hello'); //animal says helloclass Cat extends Animal &#123; constructor() &#123; super(); this.type = 'cat'; &#125;&#125;let cat = new Cat();cat.says('hello'); //cat says hello 首先定义了一个&quot;类&quot;，有constructor构造方法，this关键字则代表实例对象。换句话来说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的 class之间可以通过extends实现继承。如实例中Cat类，通过extends关键字，继承了Animal类的所有属性和fnagfa。 super关键字，它指代父亲的实例（即父亲的this对象）。子类必须在constructor方法中调用super方法，否则实例时会报错。因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用，子类就得不到this对象 ES6的继承机制，实质是看创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 箭头函数 函数的快捷写法。不需要function来创建函数，省略retrun，继承当前上下文的this 123456789101112// ES5var arr1 = [1, 2, 3];var newArr1 = arr1.map(function(x) &#123; return x + 1;&#125;);// ES6let newArr2 = arr1.map((x) =&gt; &#123; x + 1&#125;);// ES6 函数有且只有一个参数是，可以省略括号，函数中有且只有一个表达式可以省略&#123;&#125;let newArr2 = arr1.map(x =&gt; x + 1 ); tempalte string(模版字符串) 第一个用途：字符串拼接。将表达式嵌入字符串中进行拼接，语法 hello ${变量} 123456// es5var name1 = \"bai\";console.log('hello ' + name1);// es6const name2 = \"ming\";console.log(`hello $&#123;name2&#125;`); 第二个用途：多行字符串拼接 1234567// es5var msg = \"Hi \\man!\";// es6const template = `&lt;div&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/div&gt;`; destructing (解构) 简化数组和对象中信息的提取 12345678let people2 = &#123; name: 'ming', age: 20, color: ['red', 'blue']&#125;let &#123; name, age &#125; = people2;let [first, second] = people2.color;console.log(`$&#123;name&#125;----$&#123;age&#125;----$&#123;first&#125;`); default 函数默认参数 123456789// ES5 给函数定义参数默认值function foo(num) &#123; num = num || 200; return num;&#125;// ES6function foo(num = 200) &#123; return num;&#125; rest arguments （rest参数） 1234function foo(x, y, ...rest) &#123; return ((x + y) * rest.length);&#125;foo(1, 2, 'hello', true, 7); // 9 Spread Operator （展开运算符） 第一个用途：组装数组 123let color = ['red', 'yellow'];let colorful = [...color, 'green', 'blue'];console.log(colorful); // [\"red\", \"yellow\", \"green\", \"blue\"] 第二个用途：获取数组除了某几项的其他项 123let num = [1, 3, 5, 7, 9];let [first, second, ...rest] = num;console.log(rest); // [5, 7, 9] 对象 1234567891011121314/// ES5function people(name, age) &#123; return &#123; name: name, age: age &#125;;&#125;// ES6function people(name, age) &#123; return &#123; name, age &#125;;&#125; 另外：Object.assign() ES6 对象提供了Object.assign()这个方法来实现浅复制。Object.assign()可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{} 用法1：合并对象 123456var first = &#123; name: \"Bob\" &#125;;var last = &#123; lastName: \"Smith\" &#125;;var person = Object.assign(first, last);console.log(person);// Output:// &#123; name: \"Bob\", lastName: \"Smith\" &#125; 用法2：克隆对象 12var obj = &#123; person: \"Bob Smith\"&#125;;var clone = Object.assign(&#123;&#125;, obj); Promise 用同步的方式写一步代码 12345// 发起异步请求fetch('/api/todos').then(res =&gt; res.json()).then(data =&gt; (&#123; data &#125;)).catch(err =&gt; (&#123; err &#125;)); Generators 生成器（generator）是能返回一个迭代器的函数 生成器也是一种函数，最直观的表现就是比普通的function多一个*号，在其函数体内可以使用yield关键字，函数会在每个yield后暂停 如：银行取号排队办理业务 迭代器：调用一个generator时，它将返回一个迭代器对象。这个跌打器对象拥有一个叫做next的方法帮组你重启generator函数并得到了下一个值。nenxt方法不返回值，它返回的对象具有两个属性：done和value。calue是你获得的值，done用来表明你的generator是否已停止提供值。 1234567891011// 生成器function *createIterator() &#123; yield 1; yield 2; yield 3;&#125;// 生成器能像正规函数那样被调用，但会返回一个迭代器let iterator = createIterator();console.log(iterator.next().value); // 1console.log(iterator.next().value); // 2console.log(iterator.next().value); // 3 参考文献：https://www.cnblogs.com/fangsmile/p/7081194.html","tags":[]},{"title":"flex布局","date":"2018-12-04T06:14:02.897Z","path":"2018/12/04/flex布局/","text":"弹性盒子 display:flex flex为复合属性，且必须配合父元素display:flex使用。 以下6个属性设置在子元素上： &lt;ul&gt; &lt;li&gt;flex-grow：放大比例&lt;/li&gt; &lt;li&gt;flex-shrink：缩小比例&lt;/li&gt; &lt;li&gt;flex-basis：伸缩基准值&lt;/li&gt; &lt;li&gt;flex：前面三者的缩写&lt;/li&gt; &lt;li&gt;order：排列顺序&lt;/li&gt; &lt;li&gt;align：单个元素对齐方式ß&lt;/li&gt; &lt;/ul&gt;","tags":[]},{"title":"单选框和复选框","date":"2018-12-04T05:50:55.479Z","path":"2018/12/04/input/","text":"input的功能可以说是非常强大了，他的属性不同，呈现的效果是完全不一样的 单选框 123&lt;label&gt;性别：&lt;label&gt;男：&lt;input type='radio' name='gender'&gt;女：&lt;input type='radio' name='gender'&gt; 复选框 12345&lt;label&gt;爱好：&lt;label&gt;篮球：&lt;input type='checkbox' name='hobby' value=\"1\"&gt;足球：&lt;input type='checkbox' name='hobby' value=\"2\"&gt;跑步：&lt;input type='checkbox' name='hobby' value=\"3\"&gt;跳舞：&lt;input type='checkbox' name='hobby' value=\"4\"&gt; 属性 属性 值及功能 type radio:单选框 checkbox:复选框 value 提交数据到后台的值 checked 当设置 checked=true或者&quot;checked&quot; 时，该选项被默认选中 disabled true：禁用 false(默认):非禁用 checkbox视觉上忧伤三种状态： checked(选中)、unchecked(未选中)、indeterminate(不确定的) element中的input：http://element-cn.eleme.io/#/zh-CN/component/input","tags":[]},{"title":"正则表达式","date":"2018-12-03T03:51:34.789Z","path":"2018/12/03/正则表达式/","text":"正则表达式有一些普通字符和一些元字符组成。普通字符包括大小写的字母和数字，而元字符则具有特殊含义。 匹配有两种概念：一种时匹配字符，一种是匹配位置 元字符 元字符 描述 \\ 简单理解就是转义字符。将下一个字符标记符，或一个向后引用，或者一个八进制转义符。例如：&quot;\\n&quot;匹配\\n，&quot;\\n&quot;匹配换行符 ^ 行首 $ 行尾 * 前面子表达式表达式任意次。例如：zo能匹配z、zo、zoo。等价于{0,} + 前面子表达式表达式大于等于1次。例如：zo能匹配zo、zoo。等价于{1,} ? 前面子表达式表达式0次或1次。例如：do(es)能匹配do、does。等价于{0,1} {n} 匹配确定的n次，n为非负整数。例如：o{2}能匹配food中的两个o。 {n,} 至少匹配的n次，n为非负整数。例如：o{2}能匹配fooooood中的所有的o。 {n,m} 匹配n至m次，n为非负整数。例如：o{1,3}能匹配fooooood中的前三个o为1组，后三个o为一组。 [xyz] 匹配xyz任意一个 [^xyz] 匹配未包含的任意字符 [a-z] 字母范围。 [^a-z] 非字母范围。 \\b 匹配单词的边界，单词与空格间的位置。例如：er\\b可以匹配到her中的er，不能匹配herb中的 \\B 匹配非单词的边界。 \\cx 匹配有x说明的控制符，x必须是[a-Z]中的一个。例如：\\cM匹配的时control—M或者回车符 \\d 匹配数字，等价于[0-9] \\D 匹配非数字，等价于[^0-9] \\f 换页，等价于\\x0c和\\cL \\n 换行，等价于\\x0a和\\cJ \\r 回车，等价于\\x0d和\\cM \\d 任意不可见字符，包括空格、制表符、换行符等等，等价于[\\f\\n\\t\\r\\v] \\D 任意可见字符，包括空格、制表符、换行符等等，等价于[^\\f\\n\\t\\r\\v] *、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 通过在 *、+ 或 ? 限定符之后放置 ?，该表达式从&quot;贪心&quot;表达式转换为&quot;非贪心&quot;表达式或者最小匹配。","tags":[]},{"title":"vue扫码支付功能的实现","date":"2018-12-02T08:26:14.429Z","path":"2018/12/02/支付流程解析/","text":"简述：生成二维码，用户扫码支付后，然后跳转到指定的的页面 过程解析 用户点击充值按钮 弹出一个对话框 用户充值金额，点击下一步，在这部中执行的操作有两个请求， 函数a：请求根据用户填写的金额，拿到订单号； 函数b：请求根据订单号拿到我们需要的二维码； 弹出第二个对话框，第二个对话框的内容有充值的金额和二维码，充值金额在这个框中仍然可以修改， 在用户修改完成，点击保存的时候，再调用函数a和b 系统通过函数b，检测到用户扫码成功后，跳转到支付成功页面，并调用显示余额 函数a 函数a中只需要往后台发送一个请求，就是请求订单号 函数b 函数b中主要有两个请求， 第一个请求：根据订单号获得二维码 第二个请求：往后台发送用户信息，并监控用户是否以及扫码支付","tags":[]},{"title":"vue中前端接口的调用两种方式","date":"2018-12-02T02:18:03.162Z","path":"2018/12/02/vue中前接口调用/","text":"在做实际项目中，我遇到的两种调用api的方式 第一种方式 接口文件 文件名：a-manger.js 文件地址：src/api/a-manger.js 文件内容： 1234567891011121314import utils from 'src/utils'// utils文件夹里面放我们需要用到的ajax相关的文件const AManger = &#123; queryName (userid) &#123; return utils.ajax(&#123; method: 'post' //请求方式：post和get url: '接口地址' params: userid // 注意 这儿传入的是 userid = 值，es6简写 // 多个参数是，params就是一个对象，比如 params: &#123;id: id,name: name&#125; &#125;) &#125;&#125;export default aManger &lt;span style='color:red&gt;注意:&lt;/span&gt; 文件末尾一定要写上export defauly aManger 使用文件 文件名：b.vue 文件内容： 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt;此处内容省略&lt;template&gt;&lt;script&gt; import aManger from 'src/api/a-manger' export default &#123; name: 'b', data()&#123; return &#123; name: '' &#125; &#125;, methods: &#123; f (userid) &#123; aManger.queryName(userid).then((res) =&gt; &#123; // res就是后台返回的结果 // 一定要判断返回的结果 if (res.code === 200)&#123; this.name = res.data.name &#125; &#125;) &#125; &#125; &#125;&lt;script&gt;&lt;span style='color:red&gt;注意:&lt;/span&gt; 如果在调用f函数时，想要立即拿到name的值，就需要使用对f以及调用这个地方aynsc和await## 第二种方式### 接口文件文件名：d-manger.js文件地址：src/api/d-manger.js文件内容：```bashexport default &#123; GET_ACTIVITY_INFO: '接口地址'&#125; &lt;span style='color:red&gt;注意:&lt;/span&gt; 冒号前的名字要全部大写 使用文件 文件名：b.vue 文件内容： &lt;template&gt;此处内容省略&lt;template&gt; &lt;script&gt; import dManger from 'src/api/d-manger' export default { name: 'b', data(){ return { name: '' } }, methods: { f () { this.$get(dManger.GET_ACTIVITY_INFO,{ activityId: this.activityId }).then((res) =&gt; { if (res.code === 200){ this.activityId = res.data } }) } } } &lt;script&gt; &lt;span style='color:red&gt;注意:&lt;/span&gt; 如果在调用f函数时，想要立即拿到name的值，就需要使用对f以及调用这个地方aynsc和await","tags":[]},{"title":"20181127收获与问题","date":"2018-11-27T05:45:39.504Z","path":"2018/11/27/20181127/","text":"看代码 收获 &lt;ol&gt; &lt;li&gt;过渡(transition)的钩子函数：beforeEnter、enter、afterEnter&lt;/li&gt; &lt;li&gt;this.$el是在mounted中才会出现的,它指的是当前组件的的元素&lt;/li&gt; &lt;li&gt;offset和client&lt;/li&gt; &lt;li&gt;this.$nextTick：&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt; 问题 &lt;ol&gt; &lt;li&gt;slot的用法&lt;/li&gt; &lt;li&gt;v-if后面this的指向&lt;/li&gt; &lt;li&gt;$emit的用法&lt;/li&gt; &lt;li&gt;ComConstructor是什么 12345const instance = new ComConstructor(&#123; propsData: &#123; ...rest &#125;&#125;) play-video里面的fun.js文件 &lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt;","tags":[]},{"title":"javascript中offsetWidth、clientWidth、width、scrollWidth、clientX、screenX、offsetX、pageX","date":"2018-11-27T02:46:35.419Z","path":"2018/11/27/client和offset/","text":"盒子模型：content、padding、border、margin w表示宽度 h表示高度 width和height offsetWidth :返回元素的宽度（contentW+paddingW+borderW） offsetHeight :返回元素的高度（contentH+paddingH+borderH） clientWidth :返回元素的宽度（contentW+paddingW） clientHeight :返回元素的高度（contentH+paddingH） style.width :返回元素的宽度（contentW） style.height :返回元素的高度（contentH） scrollWidth :返回元素的宽度（包括元素宽度、内边距和溢出尺寸，不包括边框和外边距），无溢出的情况，与clientWidth相同） scrollHeigh :返回元素的高度（包括元素高度、内边距和溢出尺寸，不包括边框和外边距），无溢出的情况，与clientHeight相同） style.width 返回的是字符串，如28px，offsetWidth返回的是数值28； style.width/style.height与scrollWidth/scrollHeight是可读写的属性，clientWidth/clientHeight与offsetWidth/offsetHeight是只读属性 style.width的值需要事先定义，否则取到的值为空。而且必须要定义在html里(内联样式)，如果定义在css里，style.height的值仍然为空，但元素偏移有效；而offsetWidth则仍能取到。 //----------------------------------------------------------------------------------------------- top与left offsetTop :返回元素的上外缘距离最近采用定位父元素内壁的距离，如果父元素中没有采用定位的，则是获取上外边缘距离文档内壁的距离。所谓的定位就是position属性值为relative、absolute或者fixed。返回值是一个整数，单位是像素。此属性是只读的。 offsetLeft :此属性和offsetTop的原理是一样的，只不过方位不同，这里就不多介绍了。 scrollLeft :此属性可以获取或者设置对象的最左边到对象在当前窗口显示的范围内的左边的距离，也就是元素被滚动条向左拉动的距离。返回值是一个整数，单位是像素。此属性是可读写的。 scrollTop :此属性可以获取或者设置对象的最顶部到对象在当前窗口显示的范围内的顶边的距离，也就是元素滚动条被向下拉动的距离。返回值是一个整数，单位是像素。此属性是可读写的。 //------------------------------------------------------------------------------------------------- X和Y 当鼠标事件发生时（不管是onclick，还是omousemove，onmouseover等） clientX :鼠标相对于浏览器（这里说的是浏览器的有效区域）左上角x轴的坐标； 不随滚动条滚动而改变； clientY :鼠标相对于浏览器（这里说的是浏览器的有效区域）左上角y轴的坐标； 不随滚动条滚动而改变； pageX :鼠标相对于浏览器（这里说的是浏览器的有效区域）左上角x轴的坐标； 随滚动条滚动而改变； pageY :鼠标相对于浏览器（这里说的是浏览器的有效区域）左上角y轴的坐标； 随滚动条滚动而改变； screenX :鼠标相对于显示器屏幕左上角x轴的坐标； screenY :鼠标相对于显示器屏幕左上角y轴的坐标； offsetX :鼠标相对于事件源左上角X轴的坐标 offsetY :鼠标相对于事件源左上角Y轴的坐标","tags":[]},{"title":"20181126","date":"2018-11-26T10:39:49.623Z","path":"2018/11/26/result1/","text":"&lt;style&gt; { margin: 0; padding: 0; } &lt;/style&gt; 看代码的收获与问题 收获 &lt;ol&gt; &lt;li&gt;user-select: none; 文本不能选择 &lt;/li&gt; &lt;li&gt;vm.$refs 首先给元素设置属性 ref=&quot;logint&quot; 然后我们就可以通过 vm.$refs.input找到这个元素 &lt;/li&gt; &lt;li&gt;css3自定义动画 12345678@keyframes com-rotating &#123; from &#123; transform: rotate(0deg); &#125; to &#123; transform: rotate(360deg); &#125; &#125; &lt;/li&gt; &lt;li&gt;window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。 该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。 &lt;/li&gt; &lt;li&gt;兼容浏览器 12345678910&amp;::-moz-placeholder &#123; color: #bfbfbf; opacity: 1; &#125; &amp;:-ms-input-placeholder &#123; color: #bfbfbf; &#125; &amp;::-webkit-input-placeholder &#123; color: #bfbfbf; &#125; &lt;/li&gt; &lt;li&gt;属性选择器 123&amp;[disabled] &#123; cursor: not-allowed;&#125; &lt;/li&gt; &lt;/ol&gt; 问题和疑惑 &lt;ol&gt; &lt;li&gt;为什么每个文件夹下面都必有两个文件 com.vue 和 index.js 文件&lt;/li&gt; &lt;li&gt;能看懂代码，但是很多时候有一点理不清思路&lt;/li&gt; &lt;li&gt;需加强对es6相关语法的学习&lt;/li&gt; &lt;li&gt;需加强对css3的学习&lt;/li&gt; &lt;/ol&gt;","tags":[]},{"title":"vue","date":"2018-11-23T02:53:02.737Z","path":"2018/11/23/vue/","text":"v-if 判断 v-else 与v-if一起使用，两个标签必须紧挨着 v-for 绑定一个数组来渲染一个项目列表 v-for=&quot;item in items&quot; v-on 添加一个事件监听器 v-on:click=&quot;remove&quot; v-model 数据双向绑定 组件化应用构建 组建本质上是一个拥有预定义选项的一个Vue实例 创建一个组建 1234//定义名为todo-item的新组件Vue,component('todo-item',&#123; template：'&lt;li&gt;这是一个组件&lt;/li&gt;'&#125;) 1234//使用&lt;ol&gt; &lt;todo-item&gt;&lt;/todo-item&gt;&lt;/ol&gt; Vue 实例 创建vue实例 1234567var data = &#123; a:1&#125;var vue = new Vue (&#123; el:\"#app\" //vue作用的范围，必须写 data: data&#125;) 生命周期函数 12345678beforeCreate: function()&#123;&#125;created: function()&#123;&#125;beforeMounted: function()&#123;&#125;mounted: function()&#123;&#125;beforeUpdate: function()&#123;&#125;updated: function()&#123;&#125;beforeDdestory: function()&#123;&#125;destoryed: function()&#123;&#125; 模版语法 插值 Mustache语法（双大括号） 1&lt;span&gt;Message:&#123;&#123;msg&#125;&#125;&lt;/span&gt; 12//使用v-once指令 ，当msg发生变化时，span里面的内容也不会改变&lt;span v-once&gt;这个将不会改变:&#123;&#123;msg&#125;&#125;&lt;/span&gt; 原始HTML 1&lt;p&gt;Message:&lt;span v-html=\"msg\"&gt;&lt;/span&gt;&lt;/p&gt; text 1&lt;p&gt;Message:&lt;span v-text=\"msg\"&gt;&lt;/span&gt;&lt;/p&gt; 1和3不能识别msg中html语法，2会对msg中的内容进行编译 ###使用javascript表达式 例：NaN 指令 指令（Directive）是带有v-前缀的特俗特性。 参数 v-bind响应式更新HTML特性 缩写：:href 1&lt;a v-bind:href=\"url\"&gt;链接&lt;/a&gt; v-on 用于监听DOM事件 缩写： @click 1&lt;a v-on:click=\"do\"&gt;链接&lt;/a&gt; 修饰符 修饰符（Modifiers）是以半角句号.指明的特殊后缀 1&lt;form v-on:submit.prevent=\"submit\"&gt;……&lt;/form&gt; 计算属性 基础例子 1234&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"&#123;&#123; message &#125;&#125;\"&lt;/p&gt; &lt;p&gt;Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"&lt;/p&gt;&lt;/div&gt; 123456789101112var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125; 监听器 当需要在数据变化时执行异步或开销较大的操作时 绑定HTML Class 对象语法 12&lt;div v-bind:class=\"active\"&gt;绑定一个类名&lt;/div&gt;&lt;div v-bind:class=\"&#123; active: isActive，static：isStatic &#125;\"&gt;绑定多个类名&lt;/div&gt; active 这个 class 存在与否将取决于数据属性 isActive 的 值。 数组语法 对象语法 1&lt;div v-bind:class=\"[ active: isActive，static：isStatic ]\"&gt;绑定多个类名&lt;/div&gt; 用在组件 声明组件时 123Vue.component('my-component', &#123; template: '&lt;p class=\"foo bar\"&gt;Hi&lt;/p&gt;'&#125;) 使用时添加一些class 1&lt;my-component class=\"baz boo\"&gt;&lt;/my-component&gt; html渲染结果为 1&lt;p class=\"foo bar active\"&gt;Hi&lt;/p&gt; 绑定内联样式 对象语法 v-bind:style 12&lt;div v-bind:style=\"&#123;color:activeColor,fontSize:fontSize+'px'&#125;\"&gt;&lt;/div&gt;&lt;div v-bind:style=\"styleObject\"&gt;&lt;/div&gt; 绑定对象的数据语法 123456data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; 条件渲染 v-if 12345&lt;template v-if=\"ok\"&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;p&gt;p 1&lt;/p&gt; &lt;p&gt;p 2&lt;/p&gt;&lt;/template&gt; v-else元素必须紧跟在带v-if或者v-else-if的元素后面，否则它将不会被识别 key管理可复用的元素 v-show 根据条件展示元素 1&lt;h1 v-show=\"ok\"&gt;Hello!&lt;/h1&gt; 带有v-show的元素始终会被渲染并保存在dom中 &lt;span style=&quot;color:red&quot;&gt;注意&lt;/span&gt;:v-show不支持&lt;template&gt;元素，也不支持v-else v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 列表渲染 v-for =&quot;item in items&quot; v-for =&quot;item of items&quot; items可以时对象也可以是数组 v-for=&quot;(value, key) in object&quot; v-for=&quot;(value, key, index) in object&quot; v-for 取整数 123&lt;div&gt; &lt;span v-for=\"n in 10\"&gt;&#123;&#123;n&#125;&#125;&lt;/span&gt;&lt;/div&gt; 结果是：1 2 3 4 5 6 7 8 9 处于同一节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。 数组更新检测 变异方法 push() 从后插入 pop() 从后弹出 shift() 从前弹出 unshift() 从前插入 splice() 截取 sort() 排序 reverse() 反转 替换数组 filter() concat() slice() 事件处理 监听事件 v-on 指令监听Dom事件，并在出发时运行一些javascript代码 123&lt;div id=\"app\"&gt; &lt;button v-on:click=\"counter += 1\"&gt;add 1 &lt;/button&gt;&lt;/div&gt; 事件处理方法 v-on 绑定事件 1&lt;button v-on:click=\"greet\"&gt;greet&lt;button&gt; 事件修饰符 stop 阻止事件继续传递 prevent 阻止事件再重载页面 capture self once passive v-on:click.prevent.self会阻止所有的点击 v-on:click.self.prevent会阻止对元素自身的点击 按键修饰符 按键别名 enter tab delete esc space up down left right 通过全局config.keyCode对象自定义按键修饰符别名 Vue.config.keyCodes.f1 = 112 组件的组织 组件的注册类型：全局注册和局部注册 Vue.component是全局注册 通过Prop向子组件传递数据 1234Vue.component('blog-post',&#123; props: ['title'], template: '&lt;h3&gt;&lt;&#123;&#123; title &#125;&#125;/h3&gt;'&#125;) 123&lt;blog-post title=\"My journey with Vue\"&gt;&lt;/blog-post&gt;&lt;blog-post title=\"Blogging with Vue\"&gt;&lt;/blog-post&gt;&lt;blog-post title=\"Why Vue is so fun\"&gt;&lt;/blog-post&gt; 复选框 input -- checkbox 单个复选框,绑定到布尔值 12&lt;input type=\"checkbox\" id=\"\"checkbox\" v-model=\"checked\"&gt;&lt;label for=\"checkbox\"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; 多个复选框，绑定到同一个数组 12345678910&lt;div id='example'&gt; &lt;input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\"&gt; &lt;label for=\"jack\"&gt;Jack&lt;/label&gt; &lt;input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\"&gt; &lt;label for=\"john\"&gt;John&lt;/label&gt; &lt;input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\"&gt; &lt;label for=\"mike\"&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-3', data: &#123; checkedNames: [] &#125;&#125;) 单选按钮 input -- radio 123456789&lt;div id=\"example\"&gt; &lt;input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\"&gt; &lt;label for=\"one\"&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\"&gt; &lt;label for=\"two\"&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example', data: &#123; picked: '' &#125;&#125;) 选择框 select option 单选时： 123456789&lt;div id=\"example-5\"&gt; &lt;select v-model=\"selected\"&gt; &lt;option disabled value=\"\"&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: 'example-5', data: &#123; selected: '' &#125;&#125;) 多选时： 123456789&lt;div id=\"example-6\"&gt; &lt;select v-model=\"selected\" multiple style=\"width: 50px;\"&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt; 123456new Vue(&#123; el: '#example-6', data: &#123; selected: [] &#125;&#125;) 组件基础 基本示例 12345678Vue.component('button-counter',&#123; data: function()&#123; return &#123; count:0 &#125; &#125;, template: '&lt;button v-on:click=\"count++\"&gt;you clicked me &#123;&#123;count&#125;&#125; times&lt;/button&gt;'&#125; 123&lt;div id=\"components-demo\"&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt; 123new Vue(&#123; el:'#components-demo'&#125;) 组件组册 子组件中的data必须是一个function，且必须return一个对象，这个对象中可以放数据 组件名大小写 使用kebab-case(短横线分割) 例：my-component-name 使用PascalCase(驼峰式) 例：MyComponentName 全局注册 Vue.component('name',{}) 局部注册 12var ComponentA = &#123; /* ... */ &#125;var ComponentB = &#123; /* ... */ &#125; 1234567new Vue(&#123; el: '#app', components: &#123; 'component-a': ComponentA, 'component-b': ComponentB &#125;&#125;) 模块系统 在模块系统中局部注册 123456789import ComponentA from './ComponentA'import ComponentC from './ComponentC'export default &#123; components: &#123; ComponentA, ComponentC &#125;,&#125; prop 数据检测 Vue.component('my-component', { props: { // 基础的类型检查 (`null` 匹配任何类型) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: { type: String, required: true }, // 带有默认值的数字 propD: { type: Number, default: 100 }, // 带有默认值的对象 propE: { type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () { return { message: 'hello' } } }, // 自定义验证函数 propF: { validator: function (value) { // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 } } } }) ### 类型检查 type 可以是下列原生构造函数中的一个： String Number Boolean Array Object Date Function Symbol &lt;span style=&quot;color:red,font-size:18px&quot;&gt;不懂的地方：&lt;/span&gt;自定义组件的v-model、sync修饰符 ## 插槽 Vue 实现了一套内容分发的 API，这套 API 基于当前的 Web Components 规范草案，将 &lt;slot&gt; 元素作为承载分发内容的出口。","tags":[]},{"title":"git使用","date":"2018-11-22T06:55:15.430Z","path":"2018/11/22/git/","text":"mac系统自带有git，我们只需要打开终端，然后输入git系统会有提示，根据提示完成后面的操作，就可以使用git了 git常用语法 创建目录 1mkdir demo 文件创建与编辑 1.创建一个文件 1touch file 2.创建一个文件并进入一般模式 1vi 文件名 也可以vi一个已经存在的文件，进入一般模式 3.一般模式进入插入模式 按i键 4.插入模式进入一般模式 按esc 5.一般模式进入命令模式 依次按 :wq 6.查看文件内容 1cat 文件名 初始化一个git仓库 1.远程仓库地址 1git clone 远程仓库地址 2.在本地文件下 1git init git状态 git的状态分为三种：工作区-&gt;暂存区(索引区)-&gt;版本区 1.查看状态 1git status 当文件名是红色时---工作区 当文件名是绿色时---暂存区 不显示----版本区 2.工作区-&gt;️暂存区 1git add 文件名 1git add . .表示将全部工作区的文件移入暂存区 3.暂存区-&gt;版本区 1git commit -m \"file1提交\" 第一次提交的时候必须写-m和引号中的内容 4.暂存区-&gt;工作区 1git rm --cache 文件名 提交远程仓库 查看本地仓库是否已关联远程仓库 1git remote 2.若没有远程仓库或想提交另一个远程仓库，为当前仓库添加远程仓库 1git remote add 远程仓库别名 url（远程地址） 3.把文件提交到远程仓库 1git push [-u/-f] 远程仓库 本地仓库 [-u/-f]第一次提交时，必须写上其中一个","tags":[]},{"title":"两栏布局-右侧自适应","date":"2018-11-20T09:17:55.660Z","path":"2018/11/20/两栏布局-右侧自适应/","text":"利用简单的css实现左侧盒子200px定宽，右侧盒子自适应 分析：如果想让两个div在一行内展示，则需要改变div默认的display：block 实现方式：float，position，flex，table, border 结构布局 1234&lt;div class=\"content\"&gt; &lt;div class=\"left\"&gt;1111111&lt;/div&gt; &lt;div class=\"right\"&gt;2222&lt;/div&gt;&lt;/div&gt; 基础样式 123456789101112131415* &#123; padding: 0; margin: 0;&#125;.left &#123; background-color: red; width: 200px; height: 300px;&#125;.right &#123; background-color: #000; height: 300px; color: #fff;&#125; 左侧固定左侧自适应 方法一：浮动（float) 思路：给left添加float:left样式，使其脱离标准文档流，后面元素就可以占据本来left所占据的行，再给右侧的div设置margin-right:200px使两个盒子不重叠。 123456.left &#123; float: left;&#125;.right &#123; margin-left: 200px;&#125; 方法二:浮动和overflow 思路：设置float属性（不为none）时，会创建BFC，再设置overflow（不为visible）时也会产生BFC 1234567.left &#123; float: left; &#125;.right &#123; overflow: auto;&#125; 方法三；positon:absolute或者fixed 1234567left &#123; position: absolute; /*position: fixed;*/&#125;.right &#123; margin-left: 200px;&#125; 方法四；display:flex 123456.content &#123; display: flex;&#125;.right &#123; flex: 1;&#125; 方法五；dispaly:table 1234567.content &#123; display: table; width: 100%;&#125;.left,.right &#123; display: table-cell;&#125; 方法六；box-sizing 123456789101112131415.content &#123; box-sizing: content-box; font-size: 0;&#125;.left,.right &#123; display: inline-block; vertical-align: top; font-size: 14px; box-sizing: border-box;&#125;.right &#123; width: calc(100% - 200px);&#125; 总结 这个问题大的整体思路就是，div是块级元素，当我们不设置它的宽度时，它的宽度就是一行，换句话说此时它的宽度就会随着浏览器的窗口大小而改变，那么我们需要做的工作就是把左侧盒子设置固定的宽度，并让这两个盒子在一行内显示 注解 &lt;span style=&quot;color:red&quot;&gt;box-sizing&lt;/span&gt; &lt;style&gt; table th:first-of-type{ width:100px } &lt;/style&gt; 值 描述 content-box 这是由 CSS2.1 规定的宽度高度行为。&lt;/br&gt;宽度和高度分别应用到元素的内容框.&lt;br&gt;在宽度和高度之外绘制元素的内边距和边框。 boxder-box 为元素设定的宽度和高度决定了元素的边框盒。&lt;/br&gt;就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。&lt;/br&gt;通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的 inherit 规定应从父元素继承 box-sizing 属性的值。 &lt;span style=&quot;color:red&quot;&gt;标准文档流：&lt;/span&gt;一种默认状态，文档流指的是元素排版布局过程中，元素会自动从左往右，从上往下的流式排列。并最终窗体自上而下分成一行行，并在每行中从左至右的顺序排放元素。 &lt;span style=&quot;color:red&quot;&gt;BFC：&lt;/span&gt;块级格式化上下文 (Block Fromatting Context)是按照块级盒子布局的。 W3C对BFC的定义如下： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。","tags":[]},{"title":"positon、display、float","date":"2018-11-20T08:25:06.038Z","path":"2018/11/20/pos_dis_float/","text":"display属性规定元素生成框的类型。 none-缺省值（用于隐藏元素，元素会消失于视界和文档流中）， block-块级元素， inline-block-行内块级元素。 position属性规定元素的定位类型，常用于布局。 static-默认：元素出现在正常文档流中（此时不受top、left、right、bottom、z-index等属性影响）； absolute-绝对定位：脱离文档流，相对于它第一个非static父元素进行定； fixed-固定定位：相对于浏览器窗口进行定位；relative生成相对定位的元素，相对于其正常文档流中的位置进行定位，简单来说就是相对于浏览器窗口进行定位，例如：固定导航。 float属性 定义一个元素浮动方向，最初用于图像使文本环绕，现在是一种布局方式。不论浮动元素本身是何种框类型，浮动后会生成一个块级框。 三者关系 &lt;img src=&quot;../../../../images/relation.png&quot;&gt; 1，如果'display'设置为'none'，用户端必须忽略掉'position'和'float'。在这种情况下，元素不产生框。 2，否则，'position'设置为'absolute'或'fixed'，'display'设置为'block'且'float'设置为'none'。框的位置将由'top'，'right'，'bottom'和'left'属性和该框的包含块确定。 3，否则，如果'float'的值不是'none'，'display'设置为'block'并且该框浮动。 4，否则，应用指定的其它'display'属性。 即如果'position'设置为'absolute'或'fixed'且‘float’的值不为‘none’，display的值就会被设置为‘block’，所以设置display: inline; float: left;等同于float:left，display:inline 的属性并未生效。因为用户端会忽略掉对’display‘的设置。float:left和display:inline-block当然是不等同的。 position:absolute和float会隐式的改变display类型， 不论之前是什么类型的元素（display:none除外），只要设置了position:absolute或float，都会让元素以display:inline-block的方式显示，可以设置长宽，默认宽度并不占满父元素，就算是显示的设置display:inline或display:block，仍然无效。 float在IE6下的双倍边距bug就是利用添加display:inline来解决的 注意一点的是，position:relative并不能够隐式的改变display的类型","tags":[]}]